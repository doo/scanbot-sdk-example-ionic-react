'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const React = require('react');
const components = require('@ionic/core/components');
const tslib = require('tslib');
const ReactDOM = require('react-dom');
const ionAccordion_js = require('@ionic/core/components/ion-accordion.js');
const ionAccordionGroup_js = require('@ionic/core/components/ion-accordion-group.js');
const ionAvatar_js = require('@ionic/core/components/ion-avatar.js');
const ionBackdrop_js = require('@ionic/core/components/ion-backdrop.js');
const ionBadge_js = require('@ionic/core/components/ion-badge.js');
const ionBreadcrumbs_js = require('@ionic/core/components/ion-breadcrumbs.js');
const ionButtons_js = require('@ionic/core/components/ion-buttons.js');
const ionCardContent_js = require('@ionic/core/components/ion-card-content.js');
const ionCardHeader_js = require('@ionic/core/components/ion-card-header.js');
const ionCardSubtitle_js = require('@ionic/core/components/ion-card-subtitle.js');
const ionCardTitle_js = require('@ionic/core/components/ion-card-title.js');
const ionCheckbox_js = require('@ionic/core/components/ion-checkbox.js');
const ionChip_js = require('@ionic/core/components/ion-chip.js');
const ionCol_js = require('@ionic/core/components/ion-col.js');
const ionContent_js = require('@ionic/core/components/ion-content.js');
const ionDatetime_js = require('@ionic/core/components/ion-datetime.js');
const ionDatetimeButton_js = require('@ionic/core/components/ion-datetime-button.js');
const ionFab_js = require('@ionic/core/components/ion-fab.js');
const ionFabList_js = require('@ionic/core/components/ion-fab-list.js');
const ionFooter_js = require('@ionic/core/components/ion-footer.js');
const ionGrid_js = require('@ionic/core/components/ion-grid.js');
const ionHeader_js = require('@ionic/core/components/ion-header.js');
const ionImg_js = require('@ionic/core/components/ion-img.js');
const ionInfiniteScroll_js = require('@ionic/core/components/ion-infinite-scroll.js');
const ionInfiniteScrollContent_js = require('@ionic/core/components/ion-infinite-scroll-content.js');
const ionInput_js = require('@ionic/core/components/ion-input.js');
const ionItemDivider_js = require('@ionic/core/components/ion-item-divider.js');
const ionItemGroup_js = require('@ionic/core/components/ion-item-group.js');
const ionItemOptions_js = require('@ionic/core/components/ion-item-options.js');
const ionItemSliding_js = require('@ionic/core/components/ion-item-sliding.js');
const ionLabel_js = require('@ionic/core/components/ion-label.js');
const ionList_js = require('@ionic/core/components/ion-list.js');
const ionListHeader_js = require('@ionic/core/components/ion-list-header.js');
const ionMenu_js = require('@ionic/core/components/ion-menu.js');
const ionMenuButton_js = require('@ionic/core/components/ion-menu-button.js');
const ionMenuToggle_js = require('@ionic/core/components/ion-menu-toggle.js');
const ionNav_js = require('@ionic/core/components/ion-nav.js');
const ionNavLink_js = require('@ionic/core/components/ion-nav-link.js');
const ionNote_js = require('@ionic/core/components/ion-note.js');
const ionProgressBar_js = require('@ionic/core/components/ion-progress-bar.js');
const ionRadio_js = require('@ionic/core/components/ion-radio.js');
const ionRadioGroup_js = require('@ionic/core/components/ion-radio-group.js');
const ionRange_js = require('@ionic/core/components/ion-range.js');
const ionRefresher_js = require('@ionic/core/components/ion-refresher.js');
const ionRefresherContent_js = require('@ionic/core/components/ion-refresher-content.js');
const ionReorder_js = require('@ionic/core/components/ion-reorder.js');
const ionReorderGroup_js = require('@ionic/core/components/ion-reorder-group.js');
const ionRippleEffect_js = require('@ionic/core/components/ion-ripple-effect.js');
const ionRow_js = require('@ionic/core/components/ion-row.js');
const ionSearchbar_js = require('@ionic/core/components/ion-searchbar.js');
const ionSegment_js = require('@ionic/core/components/ion-segment.js');
const ionSegmentButton_js = require('@ionic/core/components/ion-segment-button.js');
const ionSelect_js = require('@ionic/core/components/ion-select.js');
const ionSelectOption_js = require('@ionic/core/components/ion-select-option.js');
const ionSkeletonText_js = require('@ionic/core/components/ion-skeleton-text.js');
const ionSlide_js = require('@ionic/core/components/ion-slide.js');
const ionSlides_js = require('@ionic/core/components/ion-slides.js');
const ionSpinner_js = require('@ionic/core/components/ion-spinner.js');
const ionSplitPane_js = require('@ionic/core/components/ion-split-pane.js');
const ionTab_js = require('@ionic/core/components/ion-tab.js');
const ionText_js = require('@ionic/core/components/ion-text.js');
const ionTextarea_js = require('@ionic/core/components/ion-textarea.js');
const ionThumbnail_js = require('@ionic/core/components/ion-thumbnail.js');
const ionTitle_js = require('@ionic/core/components/ion-title.js');
const ionToggle_js = require('@ionic/core/components/ion-toggle.js');
const ionToolbar_js = require('@ionic/core/components/ion-toolbar.js');
const ionVirtualScroll_js = require('@ionic/core/components/ion-virtual-scroll.js');
const ionBreadcrumb_js = require('@ionic/core/components/ion-breadcrumb.js');
const ionButton_js = require('@ionic/core/components/ion-button.js');
const ionCard_js = require('@ionic/core/components/ion-card.js');
const ionFabButton_js = require('@ionic/core/components/ion-fab-button.js');
const ionItemOption_js = require('@ionic/core/components/ion-item-option.js');
const ionItem_js = require('@ionic/core/components/ion-item.js');
const ionRouterLink_js = require('@ionic/core/components/ion-router-link.js');
const ionAlert_js = require('@ionic/core/components/ion-alert.js');
const ionLoading_js = require('@ionic/core/components/ion-loading.js');
const ionToast_js = require('@ionic/core/components/ion-toast.js');
const ionPicker_js = require('@ionic/core/components/ion-picker.js');
const ionActionSheet_js = require('@ionic/core/components/ion-action-sheet.js');
const ionModal_js = require('@ionic/core/components/ion-modal.js');
const ionPopover_js = require('@ionic/core/components/ion-popover.js');
const ionApp_js = require('@ionic/core/components/ion-app.js');
const ionBackButton_js = require('@ionic/core/components/ion-back-button.js');
const ionRouterOutlet_js = require('@ionic/core/components/ion-router-outlet.js');
const ionTabBar_js = require('@ionic/core/components/ion-tab-bar.js');
const ionTabButton_js = require('@ionic/core/components/ion-tab-button.js');
const ionIcon_js = require('ionicons/components/ion-icon.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const React__default = /*#__PURE__*/_interopDefaultLegacy(React);
const ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

const IonLifeCycleContext = /*@__PURE__*/ React__default["default"].createContext({
    onIonViewWillEnter: () => {
        return;
    },
    ionViewWillEnter: () => {
        return;
    },
    onIonViewDidEnter: () => {
        return;
    },
    ionViewDidEnter: () => {
        return;
    },
    onIonViewWillLeave: () => {
        return;
    },
    ionViewWillLeave: () => {
        return;
    },
    onIonViewDidLeave: () => {
        return;
    },
    ionViewDidLeave: () => {
        return;
    },
});
const DefaultIonLifeCycleContext = class {
    constructor() {
        this.ionViewWillEnterCallbacks = [];
        this.ionViewDidEnterCallbacks = [];
        this.ionViewWillLeaveCallbacks = [];
        this.ionViewDidLeaveCallbacks = [];
    }
    onIonViewWillEnter(callback) {
        if (callback.id) {
            const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);
            if (index > -1) {
                this.ionViewWillEnterCallbacks[index] = callback;
            }
            else {
                this.ionViewWillEnterCallbacks.push(callback);
            }
        }
        else {
            this.ionViewWillEnterCallbacks.push(callback);
        }
    }
    ionViewWillEnter() {
        this.ionViewWillEnterCallbacks.forEach((cb) => cb());
    }
    onIonViewDidEnter(callback) {
        if (callback.id) {
            const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);
            if (index > -1) {
                this.ionViewDidEnterCallbacks[index] = callback;
            }
            else {
                this.ionViewDidEnterCallbacks.push(callback);
            }
        }
        else {
            this.ionViewDidEnterCallbacks.push(callback);
        }
    }
    ionViewDidEnter() {
        this.ionViewDidEnterCallbacks.forEach((cb) => cb());
    }
    onIonViewWillLeave(callback) {
        if (callback.id) {
            const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);
            if (index > -1) {
                this.ionViewWillLeaveCallbacks[index] = callback;
            }
            else {
                this.ionViewWillLeaveCallbacks.push(callback);
            }
        }
        else {
            this.ionViewWillLeaveCallbacks.push(callback);
        }
    }
    ionViewWillLeave() {
        this.ionViewWillLeaveCallbacks.forEach((cb) => cb());
    }
    onIonViewDidLeave(callback) {
        if (callback.id) {
            const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);
            if (index > -1) {
                this.ionViewDidLeaveCallbacks[index] = callback;
            }
            else {
                this.ionViewDidLeaveCallbacks.push(callback);
            }
        }
        else {
            this.ionViewDidLeaveCallbacks.push(callback);
        }
    }
    ionViewDidLeave() {
        this.ionViewDidLeaveCallbacks.forEach((cb) => cb());
        this.componentCanBeDestroyed();
    }
    onComponentCanBeDestroyed(callback) {
        this.componentCanBeDestroyedCallback = callback;
    }
    componentCanBeDestroyed() {
        if (this.componentCanBeDestroyedCallback) {
            this.componentCanBeDestroyedCallback();
        }
    }
};

const withIonLifeCycle = (WrappedComponent) => {
    return class IonLifeCycle extends React__default["default"].Component {
        constructor(props) {
            super(props);
            this.componentRef = React__default["default"].createRef();
        }
        componentDidMount() {
            const element = this.componentRef.current;
            this.context.onIonViewWillEnter(() => {
                if (element && element.ionViewWillEnter) {
                    element.ionViewWillEnter();
                }
            });
            this.context.onIonViewDidEnter(() => {
                if (element && element.ionViewDidEnter) {
                    element.ionViewDidEnter();
                }
            });
            this.context.onIonViewWillLeave(() => {
                if (element && element.ionViewWillLeave) {
                    element.ionViewWillLeave();
                }
            });
            this.context.onIonViewDidLeave(() => {
                if (element && element.ionViewDidLeave) {
                    element.ionViewDidLeave();
                }
            });
        }
        render() {
            return (React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
                this.context = context;
                return React__default["default"].createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));
            }));
        }
    };
};

const useIonViewWillEnter = (callback, deps = []) => {
    const context = React.useContext(IonLifeCycleContext);
    const id = React.useRef();
    id.current = id.current || Math.floor(Math.random() * 1000000);
    React.useEffect(() => {
        callback.id = id.current;
        context.onIonViewWillEnter(callback);
    }, deps);
};
const useIonViewDidEnter = (callback, deps = []) => {
    const context = React.useContext(IonLifeCycleContext);
    const id = React.useRef();
    id.current = id.current || Math.floor(Math.random() * 1000000);
    React.useEffect(() => {
        callback.id = id.current;
        context.onIonViewDidEnter(callback);
    }, deps);
};
const useIonViewWillLeave = (callback, deps = []) => {
    const context = React.useContext(IonLifeCycleContext);
    const id = React.useRef();
    id.current = id.current || Math.floor(Math.random() * 1000000);
    React.useEffect(() => {
        callback.id = id.current;
        context.onIonViewWillLeave(callback);
    }, deps);
};
const useIonViewDidLeave = (callback, deps = []) => {
    const context = React.useContext(IonLifeCycleContext);
    const id = React.useRef();
    id.current = id.current || Math.floor(Math.random() * 1000000);
    React.useEffect(() => {
        callback.id = id.current;
        context.onIonViewDidLeave(callback);
    }, deps);
};

const NavContext = /*@__PURE__*/ React__default["default"].createContext({
    getIonRedirect: () => undefined,
    getIonRoute: () => undefined,
    getPageManager: () => undefined,
    getStackManager: () => undefined,
    goBack: (route) => {
        if (typeof window !== 'undefined') {
            if (typeof route === 'string') {
                window.location.pathname = route;
            }
            else {
                window.history.back();
            }
        }
    },
    navigate: (path) => {
        if (typeof window !== 'undefined') {
            window.location.pathname = path;
        }
    },
    hasIonicRouter: () => false,
    routeInfo: undefined,
    setCurrentTab: () => undefined,
    changeTab: (_tab, path) => {
        if (typeof window !== 'undefined') {
            window.location.pathname = path;
        }
    },
    resetTab: (_tab, path) => {
        if (typeof window !== 'undefined') {
            window.location.pathname = path;
        }
    },
});

const dashToPascalCase = (str) => str
    .toLowerCase()
    .split('-')
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');
const camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);

const attachProps = (node, newProps, oldProps = {}) => {
    // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first
    if (node instanceof Element) {
        // add any classes in className to the class list
        const className = getClassName(node.classList, newProps, oldProps);
        if (className !== '') {
            node.className = className;
        }
        Object.keys(newProps).forEach((name) => {
            if (name === 'children' ||
                name === 'style' ||
                name === 'ref' ||
                name === 'class' ||
                name === 'className' ||
                name === 'forwardedRef') {
                return;
            }
            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                const eventName = name.substring(2);
                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
                if (!isCoveredByReact(eventNameLc)) {
                    syncEvent(node, eventNameLc, newProps[name]);
                }
            }
            else {
                node[name] = newProps[name];
                const propType = typeof newProps[name];
                if (propType === 'string') {
                    node.setAttribute(camelToDashCase(name), newProps[name]);
                }
            }
        });
    }
};
const getClassName = (classList, newProps, oldProps) => {
    const newClassProp = newProps.className || newProps.class;
    const oldClassProp = oldProps.className || oldProps.class;
    // map the classes to Maps for performance
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);
    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);
    const finalClassNames = [];
    // loop through each of the current classes on the component
    // to see if it should be a part of the classNames added
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            // add it as its already included in classnames coming in from newProps
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            // add it as it has NOT been removed by user
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach((s) => finalClassNames.push(s));
    return finalClassNames.join(' ');
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
const isCoveredByReact = (eventNameSuffix) => {
    if (typeof document === 'undefined') {
        return true;
    }
    else {
        const eventName = 'on' + eventNameSuffix;
        let isSupported = eventName in document;
        if (!isSupported) {
            const element = document.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        return isSupported;
    }
};
const syncEvent = (node, eventName, newEventHandler) => {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    // Remove old listener so they don't double up.
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    // Bind new listener.
    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {
        if (newEventHandler) {
            newEventHandler.call(this, e);
        }
    }));
};
const arrayToMap = (arr) => {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
};

const setRef = (ref, value) => {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref != null) {
        // Cast as a MutableRef so we can assign current
        ref.current = value;
    }
};
const mergeRefs = (...refs) => {
    return (value) => {
        refs.forEach(ref => {
            setRef(ref, value);
        });
    };
};
const createForwardRef$1 = (ReactComponent, displayName) => {
    const forwardRef = (props, ref) => {
        return React__default["default"].createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    };
    forwardRef.displayName = displayName;
    return React__default["default"].forwardRef(forwardRef);
};
const defineCustomElement = (tagName, customElement) => {
    if (customElement !== undefined &&
        typeof customElements !== 'undefined' &&
        !customElements.get(tagName)) {
        customElements.define(tagName, customElement);
    }
};

const createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) => {
    if (defineCustomElement !== undefined) {
        defineCustomElement();
    }
    const displayName = dashToPascalCase(tagName);
    const ReactComponent = class extends React__default["default"].Component {
        constructor(props) {
            super(props);
            this.setComponentElRef = (element) => {
                this.componentEl = element;
            };
        }
        componentDidMount() {
            this.componentDidUpdate(this.props);
        }
        componentDidUpdate(prevProps) {
            attachProps(this.componentEl, this.props, prevProps);
        }
        render() {
            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = tslib.__rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
            let propsToPass = Object.keys(cProps).reduce((acc, name) => {
                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                    const eventName = name.substring(2).toLowerCase();
                    if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {
                        acc[name] = cProps[name];
                    }
                }
                else {
                    acc[name] = cProps[name];
                }
                return acc;
            }, {});
            if (manipulatePropsFunction) {
                propsToPass = manipulatePropsFunction(this.props, propsToPass);
            }
            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });
            /**
             * We use createElement here instead of
             * React.createElement to work around a
             * bug in Vite (https://github.com/vitejs/vite/issues/6104).
             * React.createElement causes all elements to be rendered
             * as <tagname> instead of the actual Web Component.
             */
            return React.createElement(tagName, newProps, children);
        }
        static get displayName() {
            return displayName;
        }
    };
    // If context was passed to createReactComponent then conditionally add it to the Component Class
    if (ReactComponentContext) {
        ReactComponent.contextType = ReactComponentContext;
    }
    return createForwardRef$1(ReactComponent, displayName);
};

/* eslint-disable */
const IonAccordion = /*@__PURE__*/ createReactComponent('ion-accordion', undefined, undefined, ionAccordion_js.defineCustomElement);
const IonAccordionGroup = /*@__PURE__*/ createReactComponent('ion-accordion-group', undefined, undefined, ionAccordionGroup_js.defineCustomElement);
const IonAvatar = /*@__PURE__*/ createReactComponent('ion-avatar', undefined, undefined, ionAvatar_js.defineCustomElement);
const IonBackdrop = /*@__PURE__*/ createReactComponent('ion-backdrop', undefined, undefined, ionBackdrop_js.defineCustomElement);
const IonBadge = /*@__PURE__*/ createReactComponent('ion-badge', undefined, undefined, ionBadge_js.defineCustomElement);
const IonBreadcrumbs = /*@__PURE__*/ createReactComponent('ion-breadcrumbs', undefined, undefined, ionBreadcrumbs_js.defineCustomElement);
const IonButtons = /*@__PURE__*/ createReactComponent('ion-buttons', undefined, undefined, ionButtons_js.defineCustomElement);
const IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content', undefined, undefined, ionCardContent_js.defineCustomElement);
const IonCardHeader = /*@__PURE__*/ createReactComponent('ion-card-header', undefined, undefined, ionCardHeader_js.defineCustomElement);
const IonCardSubtitle = /*@__PURE__*/ createReactComponent('ion-card-subtitle', undefined, undefined, ionCardSubtitle_js.defineCustomElement);
const IonCardTitle = /*@__PURE__*/ createReactComponent('ion-card-title', undefined, undefined, ionCardTitle_js.defineCustomElement);
const IonCheckbox = /*@__PURE__*/ createReactComponent('ion-checkbox', undefined, undefined, ionCheckbox_js.defineCustomElement);
const IonChip = /*@__PURE__*/ createReactComponent('ion-chip', undefined, undefined, ionChip_js.defineCustomElement);
const IonCol = /*@__PURE__*/ createReactComponent('ion-col', undefined, undefined, ionCol_js.defineCustomElement);
const IonContent = /*@__PURE__*/ createReactComponent('ion-content', undefined, undefined, ionContent_js.defineCustomElement);
const IonDatetime = /*@__PURE__*/ createReactComponent('ion-datetime', undefined, undefined, ionDatetime_js.defineCustomElement);
const IonDatetimeButton = /*@__PURE__*/ createReactComponent('ion-datetime-button', undefined, undefined, ionDatetimeButton_js.defineCustomElement);
const IonFab = /*@__PURE__*/ createReactComponent('ion-fab', undefined, undefined, ionFab_js.defineCustomElement);
const IonFabList = /*@__PURE__*/ createReactComponent('ion-fab-list', undefined, undefined, ionFabList_js.defineCustomElement);
const IonFooter = /*@__PURE__*/ createReactComponent('ion-footer', undefined, undefined, ionFooter_js.defineCustomElement);
const IonGrid = /*@__PURE__*/ createReactComponent('ion-grid', undefined, undefined, ionGrid_js.defineCustomElement);
const IonHeader = /*@__PURE__*/ createReactComponent('ion-header', undefined, undefined, ionHeader_js.defineCustomElement);
const IonImg = /*@__PURE__*/ createReactComponent('ion-img', undefined, undefined, ionImg_js.defineCustomElement);
const IonInfiniteScroll = /*@__PURE__*/ createReactComponent('ion-infinite-scroll', undefined, undefined, ionInfiniteScroll_js.defineCustomElement);
const IonInfiniteScrollContent = /*@__PURE__*/ createReactComponent('ion-infinite-scroll-content', undefined, undefined, ionInfiniteScrollContent_js.defineCustomElement);
const IonInput = /*@__PURE__*/ createReactComponent('ion-input', undefined, undefined, ionInput_js.defineCustomElement);
const IonItemDivider = /*@__PURE__*/ createReactComponent('ion-item-divider', undefined, undefined, ionItemDivider_js.defineCustomElement);
const IonItemGroup = /*@__PURE__*/ createReactComponent('ion-item-group', undefined, undefined, ionItemGroup_js.defineCustomElement);
const IonItemOptions = /*@__PURE__*/ createReactComponent('ion-item-options', undefined, undefined, ionItemOptions_js.defineCustomElement);
const IonItemSliding = /*@__PURE__*/ createReactComponent('ion-item-sliding', undefined, undefined, ionItemSliding_js.defineCustomElement);
const IonLabel = /*@__PURE__*/ createReactComponent('ion-label', undefined, undefined, ionLabel_js.defineCustomElement);
const IonList = /*@__PURE__*/ createReactComponent('ion-list', undefined, undefined, ionList_js.defineCustomElement);
const IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header', undefined, undefined, ionListHeader_js.defineCustomElement);
const IonMenu = /*@__PURE__*/ createReactComponent('ion-menu', undefined, undefined, ionMenu_js.defineCustomElement);
const IonMenuButton = /*@__PURE__*/ createReactComponent('ion-menu-button', undefined, undefined, ionMenuButton_js.defineCustomElement);
const IonMenuToggle = /*@__PURE__*/ createReactComponent('ion-menu-toggle', undefined, undefined, ionMenuToggle_js.defineCustomElement);
const IonNavLink = /*@__PURE__*/ createReactComponent('ion-nav-link', undefined, undefined, ionNavLink_js.defineCustomElement);
const IonNote = /*@__PURE__*/ createReactComponent('ion-note', undefined, undefined, ionNote_js.defineCustomElement);
const IonProgressBar = /*@__PURE__*/ createReactComponent('ion-progress-bar', undefined, undefined, ionProgressBar_js.defineCustomElement);
const IonRadio = /*@__PURE__*/ createReactComponent('ion-radio', undefined, undefined, ionRadio_js.defineCustomElement);
const IonRadioGroup = /*@__PURE__*/ createReactComponent('ion-radio-group', undefined, undefined, ionRadioGroup_js.defineCustomElement);
const IonRange = /*@__PURE__*/ createReactComponent('ion-range', undefined, undefined, ionRange_js.defineCustomElement);
const IonRefresher = /*@__PURE__*/ createReactComponent('ion-refresher', undefined, undefined, ionRefresher_js.defineCustomElement);
const IonRefresherContent = /*@__PURE__*/ createReactComponent('ion-refresher-content', undefined, undefined, ionRefresherContent_js.defineCustomElement);
const IonReorder = /*@__PURE__*/ createReactComponent('ion-reorder', undefined, undefined, ionReorder_js.defineCustomElement);
const IonReorderGroup = /*@__PURE__*/ createReactComponent('ion-reorder-group', undefined, undefined, ionReorderGroup_js.defineCustomElement);
const IonRippleEffect = /*@__PURE__*/ createReactComponent('ion-ripple-effect', undefined, undefined, ionRippleEffect_js.defineCustomElement);
const IonRow = /*@__PURE__*/ createReactComponent('ion-row', undefined, undefined, ionRow_js.defineCustomElement);
const IonSearchbar = /*@__PURE__*/ createReactComponent('ion-searchbar', undefined, undefined, ionSearchbar_js.defineCustomElement);
const IonSegment = /*@__PURE__*/ createReactComponent('ion-segment', undefined, undefined, ionSegment_js.defineCustomElement);
const IonSegmentButton = /*@__PURE__*/ createReactComponent('ion-segment-button', undefined, undefined, ionSegmentButton_js.defineCustomElement);
const IonSelect = /*@__PURE__*/ createReactComponent('ion-select', undefined, undefined, ionSelect_js.defineCustomElement);
const IonSelectOption = /*@__PURE__*/ createReactComponent('ion-select-option', undefined, undefined, ionSelectOption_js.defineCustomElement);
const IonSkeletonText = /*@__PURE__*/ createReactComponent('ion-skeleton-text', undefined, undefined, ionSkeletonText_js.defineCustomElement);
const IonSlide = /*@__PURE__*/ createReactComponent('ion-slide', undefined, undefined, ionSlide_js.defineCustomElement);
const IonSlides = /*@__PURE__*/ createReactComponent('ion-slides', undefined, undefined, ionSlides_js.defineCustomElement);
const IonSpinner = /*@__PURE__*/ createReactComponent('ion-spinner', undefined, undefined, ionSpinner_js.defineCustomElement);
const IonSplitPane = /*@__PURE__*/ createReactComponent('ion-split-pane', undefined, undefined, ionSplitPane_js.defineCustomElement);
const IonTab = /*@__PURE__*/ createReactComponent('ion-tab', undefined, undefined, ionTab_js.defineCustomElement);
const IonText = /*@__PURE__*/ createReactComponent('ion-text', undefined, undefined, ionText_js.defineCustomElement);
const IonTextarea = /*@__PURE__*/ createReactComponent('ion-textarea', undefined, undefined, ionTextarea_js.defineCustomElement);
const IonThumbnail = /*@__PURE__*/ createReactComponent('ion-thumbnail', undefined, undefined, ionThumbnail_js.defineCustomElement);
const IonTitle = /*@__PURE__*/ createReactComponent('ion-title', undefined, undefined, ionTitle_js.defineCustomElement);
const IonToggle = /*@__PURE__*/ createReactComponent('ion-toggle', undefined, undefined, ionToggle_js.defineCustomElement);
const IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar', undefined, undefined, ionToolbar_js.defineCustomElement);
const IonVirtualScroll = /*@__PURE__*/ createReactComponent('ion-virtual-scroll', undefined, undefined, ionVirtualScroll_js.defineCustomElement);

const createForwardRef = (ReactComponent, displayName) => {
    const forwardRef = (props, ref) => {
        return React__default["default"].createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    };
    forwardRef.displayName = displayName;
    return React__default["default"].forwardRef(forwardRef);
};
const isPlatform = (platform) => {
    return components.isPlatform(window, platform);
};
const getPlatforms = () => {
    return components.getPlatforms(window);
};
const getConfig = () => {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return Ionic.config;
        }
    }
    return null;
};

const createRoutingComponent = (tagName, customElement) => {
    defineCustomElement(tagName, customElement);
    const displayName = dashToPascalCase(tagName);
    const ReactComponent = class extends React__default["default"].Component {
        constructor(props) {
            super(props);
            this.handleClick = (e) => {
                const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
                if (routerLink !== undefined) {
                    e.preventDefault();
                    this.context.navigate(routerLink, routerDirection, undefined, routerAnimation, routerOptions);
                }
            };
            // Create a local ref to to attach props to the wrapped element.
            this.ref = React__default["default"].createRef();
            // React refs must be stable (not created inline).
            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
        }
        componentDidMount() {
            this.componentDidUpdate(this.props);
        }
        componentDidUpdate(prevProps) {
            const node = this.ref.current;
            attachProps(node, this.props, prevProps);
        }
        render() {
            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = tslib.__rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
            const propsToPass = Object.keys(cProps).reduce((acc, name) => {
                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                    const eventName = name.substring(2).toLowerCase();
                    if (isCoveredByReact(eventName)) {
                        acc[name] = cProps[name];
                    }
                }
                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {
                    acc[camelToDashCase(name)] = cProps[name];
                }
                return acc;
            }, {});
            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
            if (this.props.routerLink && !this.props.href) {
                newProps.href = this.props.routerLink;
            }
            if (newProps.onClick) {
                const oldClick = newProps.onClick;
                newProps.onClick = (e) => {
                    oldClick(e);
                    if (!e.defaultPrevented) {
                        this.handleClick(e);
                    }
                };
            }
            else {
                newProps.onClick = this.handleClick;
            }
            return React.createElement(tagName, newProps, children);
        }
        static get displayName() {
            return displayName;
        }
        static get contextType() {
            return NavContext;
        }
    };
    return createForwardRef(ReactComponent, displayName);
};

const IonRouterLink = /*@__PURE__*/ createRoutingComponent('ion-router-link', ionRouterLink_js.IonRouterLink);
const IonButton = /*@__PURE__*/ createRoutingComponent('ion-button', ionButton_js.IonButton);
const IonCard = /*@__PURE__*/ createRoutingComponent('ion-card', ionCard_js.IonCard);
const IonFabButton = /*@__PURE__*/ createRoutingComponent('ion-fab-button', ionFabButton_js.IonFabButton);
const IonItem = /*@__PURE__*/ createRoutingComponent('ion-item', ionItem_js.IonItem);
const IonItemOption = /*@__PURE__*/ createRoutingComponent('ion-item-option', ionItemOption_js.IonItemOption);
const IonBreadcrumb = /*@__PURE__*/ createRoutingComponent('ion-breadcrumb', ionBreadcrumb_js.IonBreadcrumb);

const createControllerComponent = (tagName, controller, defineCustomElement) => {
    if (defineCustomElement) {
        defineCustomElement();
    }
    const displayName = dashToPascalCase(tagName);
    const didDismissEventName = `on${displayName}DidDismiss`;
    const didPresentEventName = `on${displayName}DidPresent`;
    const willDismissEventName = `on${displayName}WillDismiss`;
    const willPresentEventName = `on${displayName}WillPresent`;
    class Overlay extends React__default["default"].Component {
        constructor(props) {
            super(props);
            this.willUnmount = false;
            this.handleDismiss = this.handleDismiss.bind(this);
        }
        static get displayName() {
            return displayName;
        }
        async componentDidMount() {
            /**
             * Starting in React v18, strict mode will unmount and remount a component.
             * See: https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors
             *
             * We need to reset this flag when the component is re-mounted so that
             * overlay.present() will be called and the overlay will display.
             */
            this.willUnmount = false;
            const { isOpen } = this.props;
            if (isOpen) {
                this.present();
            }
        }
        componentWillUnmount() {
            this.willUnmount = true;
            if (this.overlay) {
                this.overlay.dismiss();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.overlay.dismiss();
            }
        }
        handleDismiss(event) {
            if (this.props.onDidDismiss) {
                this.props.onDidDismiss(event);
            }
            setRef(this.props.forwardedRef, null);
        }
        async present(prevProps) {
            const _a = this.props, cProps = tslib.__rest(_a, ["isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
            if (this.overlay) {
                this.overlay.remove();
            }
            this.overlay = await controller.create(Object.assign({}, cProps));
            attachProps(this.overlay, {
                [didDismissEventName]: this.handleDismiss,
                [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),
                [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),
                [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e),
            }, prevProps);
            // Check isOpen again since the value could have changed during the async call to controller.create
            // It's also possible for the component to have become unmounted.
            if (this.props.isOpen === true && this.willUnmount === false) {
                setRef(this.props.forwardedRef, this.overlay);
                await this.overlay.present();
            }
        }
        render() {
            return null;
        }
    }
    return React__default["default"].forwardRef((props, ref) => {
        return React__default["default"].createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
    });
};

const IonAlert = /*@__PURE__*/ createControllerComponent('ion-alert', components.alertController, ionAlert_js.defineCustomElement);

const IonLoading = /*@__PURE__*/ createControllerComponent('ion-loading', components.loadingController, ionLoading_js.defineCustomElement);

const toastController = {
    create: (options) => components.toastController.create(options),
    dismiss: (data, role, id) => components.toastController.dismiss(data, role, id),
    getTop: () => components.toastController.getTop(),
};
const IonToast = /*@__PURE__*/ createControllerComponent('ion-toast', toastController, ionToast_js.defineCustomElement);

const IonPicker = /*@__PURE__*/ createControllerComponent('ion-picker', components.pickerController, ionPicker_js.defineCustomElement);

const createOverlayComponent = (tagName, controller, defineCustomElement) => {
    if (defineCustomElement !== undefined) {
        defineCustomElement();
    }
    const displayName = dashToPascalCase(tagName);
    const didDismissEventName = `on${displayName}DidDismiss`;
    const didPresentEventName = `on${displayName}DidPresent`;
    const willDismissEventName = `on${displayName}WillDismiss`;
    const willPresentEventName = `on${displayName}WillPresent`;
    class Overlay extends React__default["default"].Component {
        constructor(props) {
            super(props);
            this.isDismissing = false;
            if (typeof document !== 'undefined') {
                this.el = document.createElement('div');
            }
            this.handleDismiss = this.handleDismiss.bind(this);
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            if (this.props.isOpen) {
                this.present();
            }
        }
        componentWillUnmount() {
            if (this.overlay) {
                this.overlay.dismiss();
            }
        }
        handleDismiss(event) {
            if (this.props.onDidDismiss) {
                this.props.onDidDismiss(event);
            }
            setRef(this.props.forwardedRef, null);
        }
        shouldComponentUpdate(nextProps) {
            // Check if the overlay component is about to dismiss
            if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {
                this.isDismissing = true;
            }
            return true;
        }
        async componentDidUpdate(prevProps) {
            if (this.overlay) {
                attachProps(this.overlay, this.props, prevProps);
            }
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.overlay.dismiss();
                this.isDismissing = false;
                /**
                 * Now that the overlay is dismissed
                 * we need to render again so that any
                 * inner components will be unmounted
                 */
                this.forceUpdate();
            }
        }
        async present(prevProps) {
            const _a = this.props, cProps = tslib.__rest(_a, ["children", "isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
            const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });
            this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));
            setRef(this.props.forwardedRef, this.overlay);
            attachProps(this.overlay, elementProps, prevProps);
            await this.overlay.present();
        }
        render() {
            /**
             * Continue to render the component even when
             * overlay is dismissing otherwise component
             * will be hidden before animation is done.
             */
            return ReactDOM__default["default"].createPortal(this.props.isOpen || this.isDismissing ? this.props.children : null, this.el);
        }
    }
    return React__default["default"].forwardRef((props, ref) => {
        return React__default["default"].createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
    });
};

const actionSheetController = {
    create: (options) => components.actionSheetController.create(options),
    dismiss: (data, role, id) => components.actionSheetController.dismiss(data, role, id),
    getTop: () => components.actionSheetController.getTop(),
};
const IonActionSheet = /*@__PURE__*/ createOverlayComponent('ion-action-sheet', actionSheetController, ionActionSheet_js.defineCustomElement);

const createInlineOverlayComponent = (tagName, defineCustomElement) => {
    if (defineCustomElement) {
        defineCustomElement();
    }
    const displayName = dashToPascalCase(tagName);
    const ReactComponent = class extends React__default["default"].Component {
        constructor(props) {
            super(props);
            // Create a local ref to to attach props to the wrapped element.
            this.ref = React__default["default"].createRef();
            // React refs must be stable (not created inline).
            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
            // Component is hidden by default
            this.state = { isOpen: false };
            // Create a local ref to the inner child element.
            this.wrapperRef = React__default["default"].createRef();
        }
        componentDidMount() {
            var _a, _b, _c;
            this.componentDidUpdate(this.props);
            /**
             * Mount the inner component when the
             * overlay is about to open.
             *
             * For ion-popover, this is when `ionMount` is emitted.
             * For other overlays, this is when `willPresent` is emitted.
             */
            (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('ionMount', () => {
                this.setState({ isOpen: true });
            });
            /**
             * Mount the inner component
             * when overlay is about to open.
             * Also manually call the onWillPresent
             * handler if present as setState will
             * cause the event handlers to be
             * destroyed and re-created.
             */
            (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('willPresent', (evt) => {
                this.setState({ isOpen: true });
                this.props.onWillPresent && this.props.onWillPresent(evt);
            });
            /**
             * Unmount the inner component.
             * React will call Node.removeChild
             * which expects the child to be
             * a direct descendent of the parent
             * but due to the presence of
             * Web Component slots, this is not
             * always the case. To work around this
             * we move the inner component to the root
             * of the Web Component so React can
             * cleanup properly.
             */
            (_c = this.ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener('didDismiss', (evt) => {
                const wrapper = this.wrapperRef.current;
                const el = this.ref.current;
                /**
                 * This component might be unmounted already, if the containing
                 * element was removed while the popover was still open. (For
                 * example, if an item contains an inline popover with a button
                 * that removes the item.)
                 */
                if (wrapper && el) {
                    el.append(wrapper);
                    this.setState({ isOpen: false });
                }
                this.props.onDidDismiss && this.props.onDidDismiss(evt);
            });
        }
        componentDidUpdate(prevProps) {
            const node = this.ref.current;
            attachProps(node, this.props, prevProps);
        }
        render() {
            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = tslib.__rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
            const propsToPass = Object.keys(cProps).reduce((acc, name) => {
                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
                    const eventName = name.substring(2).toLowerCase();
                    if (isCoveredByReact(eventName)) {
                        acc[name] = cProps[name];
                    }
                }
                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {
                    acc[camelToDashCase(name)] = cProps[name];
                }
                return acc;
            }, {});
            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
            return React.createElement('template', {}, React.createElement(tagName, newProps, 
            /**
             * We only want the inner component
             * to be mounted if the overlay is open,
             * so conditionally render the component
             * based on the isOpen state.
             */
            this.state.isOpen || this.props.keepContentsMounted
                ? React.createElement('div', {
                    id: 'ion-react-wrapper',
                    ref: this.wrapperRef,
                    className: 'ion-delegate-host',
                    style: {
                        display: 'flex',
                        flexDirection: 'column',
                        height: '100%',
                    },
                }, children)
                : null));
        }
        static get displayName() {
            return displayName;
        }
    };
    return createForwardRef(ReactComponent, displayName);
};

const IonModal = /*@__PURE__*/ createInlineOverlayComponent('ion-modal', ionModal_js.defineCustomElement);

const IonPopover = /*@__PURE__*/ createInlineOverlayComponent('ion-popover', ionPopover_js.defineCustomElement);

const IonContext = React__default["default"].createContext({
    addOverlay: () => {
        return;
    },
    removeOverlay: () => {
        return;
    },
});

/**
 * Manages overlays that are added via the useOverlay hook.
 * This is a standalone component so changes to its children don't cause other descendant
 * components to re-render when overlays are added. However, we need to communicate with the IonContext
 * that is set up in <IonApp />, so we register callbacks so when overlays are added to IonContext,
 * they ultimately added here.
 */
const IonOverlayManager = ({ onAddOverlay, onRemoveOverlay, }) => {
    /**
     * Because of the way we're passing around the addOverlay and removeOverlay
     * callbacks, by the time they finally get called, they use a stale reference
     * to the state that only has the initial values. So if two overlays are opened
     * at the same time, both using useIonModal or similar (such as through nesting),
     * the second will erase the first from the overlays list. This causes the content
     * of the first overlay to unmount.
     *
     * We wrap the state in useRef to ensure the two callbacks always use the most
     * up-to-date version.
     *
     * Further reading: https://stackoverflow.com/a/56554056
     */
    const [overlays, setOverlays] = React.useState({});
    const overlaysRef = React.useRef({});
    overlaysRef.current = overlays;
    React.useEffect(() => {
        /* Setup the callbacks that get called from <IonApp /> */
        onAddOverlay(addOverlay);
        onRemoveOverlay(removeOverlay);
    }, []);
    const addOverlay = (id, component, containerElement) => {
        const newOverlays = Object.assign({}, overlaysRef.current);
        newOverlays[id] = { component, containerElement };
        setOverlays(newOverlays);
    };
    const removeOverlay = (id) => {
        const newOverlays = Object.assign({}, overlaysRef.current);
        delete newOverlays[id];
        setOverlays(newOverlays);
    };
    const overlayKeys = Object.keys(overlays);
    return (React__default["default"].createElement(React__default["default"].Fragment, null, overlayKeys.map((key) => {
        const overlay = overlays[key];
        return ReactDOM__default["default"].createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);
    })));
};

const IonTabButtonInner = /*@__PURE__*/ createReactComponent('ion-tab-button', undefined, undefined, ionTabButton_js.defineCustomElement);
const IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar', undefined, undefined, ionTabBar_js.defineCustomElement);
const IonBackButtonInner = /*@__PURE__*/ createReactComponent('ion-back-button', undefined, undefined, ionBackButton_js.defineCustomElement);
const IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet', undefined, undefined, ionRouterOutlet_js.defineCustomElement);
const IonAppInner = /*@__PURE__*/ createReactComponent('ion-app', undefined, undefined, ionApp_js.defineCustomElement);
// ionicons
const IonIconInner = /*@__PURE__*/ createReactComponent('ion-icon', undefined, undefined, ionIcon_js.defineCustomElement);

const IonApp = /*@__PURE__*/ (() => class extends React__default["default"].Component {
    constructor(props) {
        super(props);
        /*
          Wire up methods to call into IonOverlayManager
        */
        this.ionContext = {
            addOverlay: (id, overlay, containerElement) => {
                if (this.addOverlayCallback) {
                    this.addOverlayCallback(id, overlay, containerElement);
                }
            },
            removeOverlay: (id) => {
                if (this.removeOverlayCallback) {
                    this.removeOverlayCallback(id);
                }
            },
        };
    }
    render() {
        return (React__default["default"].createElement(IonContext.Provider, { value: this.ionContext },
            React__default["default"].createElement(IonAppInner, Object.assign({}, this.props), this.props.children),
            React__default["default"].createElement(IonOverlayManager, { onAddOverlay: (callback) => {
                    this.addOverlayCallback = callback;
                }, onRemoveOverlay: (callback) => {
                    this.removeOverlayCallback = callback;
                } })));
    }
    static get displayName() {
        return 'IonApp';
    }
})();

const StackContext = React__default["default"].createContext({
    registerIonPage: () => undefined,
    isInOutlet: () => false,
});

class PageManager extends React__default["default"].PureComponent {
    constructor(props) {
        super(props);
        this.ionPageElementRef = React__default["default"].createRef();
        // React refs must be stable (not created inline).
        this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
    }
    componentDidMount() {
        if (this.ionPageElementRef.current) {
            if (this.context.isInOutlet()) {
                this.ionPageElementRef.current.classList.add('ion-page-invisible');
            }
            this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
            this.ionPageElementRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            this.ionPageElementRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            this.ionPageElementRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            this.ionPageElementRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    componentWillUnmount() {
        if (this.ionPageElementRef.current) {
            this.ionPageElementRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            this.ionPageElementRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            this.ionPageElementRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            this.ionPageElementRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    ionViewWillEnterHandler() {
        this.ionLifeCycleContext.ionViewWillEnter();
    }
    ionViewDidEnterHandler() {
        this.ionLifeCycleContext.ionViewDidEnter();
    }
    ionViewWillLeaveHandler() {
        this.ionLifeCycleContext.ionViewWillLeave();
    }
    ionViewDidLeaveHandler() {
        this.ionLifeCycleContext.ionViewDidLeave();
    }
    render() {
        const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = tslib.__rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
        return (React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
            this.ionLifeCycleContext = context;
            return (React__default["default"].createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children));
        }));
    }
    static get contextType() {
        return StackContext;
    }
}

class IonPageInternal extends React__default["default"].Component {
    constructor(props) {
        super(props);
    }
    render() {
        const _a = this.props, { className, children, forwardedRef } = _a, props = tslib.__rest(_a, ["className", "children", "forwardedRef"]);
        return this.context.hasIonicRouter() ? (React__default["default"].createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo, forwardedRef: forwardedRef }, props), children)) : (React__default["default"].createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));
    }
    static get displayName() {
        return 'IonPage';
    }
    static get contextType() {
        return NavContext;
    }
}
const IonPage = createForwardRef(IonPageInternal, 'IonPage');

const ReactDelegate = (addView, removeView) => {
    const refMap = new WeakMap();
    const attachViewToDom = async (parentElement, component, propsOrDataObj, cssClasses) => {
        const div = document.createElement('div');
        cssClasses && div.classList.add(...cssClasses);
        parentElement.appendChild(div);
        const componentWithProps = component(propsOrDataObj);
        const hostComponent = ReactDOM.createPortal(componentWithProps, div);
        refMap.set(component, hostComponent);
        addView(hostComponent);
        return Promise.resolve(div);
    };
    const removeViewFromDom = (_container, component) => {
        const hostComponent = refMap.get(component);
        hostComponent && removeView(hostComponent);
        return Promise.resolve();
    };
    return {
        attachViewToDom,
        removeViewFromDom,
    };
};

const IonNavInner = createReactComponent('ion-nav', undefined, undefined, ionNav_js.defineCustomElement);
const IonNavInternal = (_a) => {
    var { children, forwardedRef } = _a, restOfProps = tslib.__rest(_a, ["children", "forwardedRef"]);
    const [views, setViews] = React.useState([]);
    /**
     * Allows us to create React components that are rendered within
     * the context of the IonNav component.
     */
    const addView = (view) => setViews([...views, view]);
    const removeView = (view) => setViews(views.filter((v) => v !== view));
    const delegate = ReactDelegate(addView, removeView);
    return (React__default["default"].createElement(IonNavInner, Object.assign({ delegate: delegate, ref: forwardedRef }, restOfProps), views));
};
const IonNav = createForwardRef(IonNavInternal, 'IonNav');

const IonTabsContext = React__default["default"].createContext({
    activeTab: undefined,
    selectTab: () => false,
});

const HTMLElementSSR = (typeof HTMLElement !== 'undefined'
    ? HTMLElement
    : class {
    });

class OutletPageManager extends React__default["default"].Component {
    constructor(props) {
        super(props);
        this.outletIsReady = false;
    }
    componentDidMount() {
        if (this.ionRouterOutlet) {
            /**
             * This avoids multiple raf calls
             * when React unmounts + remounts components.
             */
            if (!this.outletIsReady) {
                components.componentOnReady(this.ionRouterOutlet, () => {
                    this.outletIsReady = true;
                    this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
                });
            }
            this.ionRouterOutlet.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            this.ionRouterOutlet.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            this.ionRouterOutlet.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            this.ionRouterOutlet.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    componentWillUnmount() {
        if (this.ionRouterOutlet) {
            this.ionRouterOutlet.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            this.ionRouterOutlet.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            this.ionRouterOutlet.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            this.ionRouterOutlet.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    ionViewWillEnterHandler() {
        this.ionLifeCycleContext.ionViewWillEnter();
    }
    ionViewDidEnterHandler() {
        this.ionLifeCycleContext.ionViewDidEnter();
    }
    ionViewWillLeaveHandler() {
        this.ionLifeCycleContext.ionViewWillLeave();
    }
    ionViewDidLeaveHandler() {
        this.ionLifeCycleContext.ionViewDidLeave();
    }
    render() {
        const _a = this.props, { StackManager, children, routeInfo } = _a, props = tslib.__rest(_a, ["StackManager", "children", "routeInfo"]);
        return (React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
            this.ionLifeCycleContext = context;
            return (React__default["default"].createElement(StackManager, { routeInfo: routeInfo },
                React__default["default"].createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => (this.ionRouterOutlet = val) }, props), children)));
        }));
    }
    static get contextType() {
        return StackContext;
    }
}

class IonRouterOutletContainer extends React__default["default"].Component {
    constructor(props) {
        super(props);
    }
    render() {
        const StackManager = this.context.getStackManager();
        const _a = this.props, { children, forwardedRef } = _a, props = tslib.__rest(_a, ["children", "forwardedRef"]);
        return this.context.hasIonicRouter() ? (props.ionPage ? (React__default["default"].createElement(OutletPageManager, Object.assign({ StackManager: StackManager, routeInfo: this.context.routeInfo }, props), children)) : (React__default["default"].createElement(StackManager, { routeInfo: this.context.routeInfo },
            React__default["default"].createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef: forwardedRef }), children)))) : (React__default["default"].createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children));
    }
    static get contextType() {
        return NavContext;
    }
}
const IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');

const IonTabButton = /*@__PURE__*/ (() => class extends React__default["default"].Component {
    constructor(props) {
        super(props);
        this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
    }
    handleIonTabButtonClick() {
        if (this.props.onClick) {
            this.props.onClick(new CustomEvent('ionTabButtonClick', {
                detail: {
                    tab: this.props.tab,
                    href: this.props.href,
                    routeOptions: this.props.routerOptions,
                },
            }));
        }
    }
    render() {
        /**
         * onClick is excluded from the props, since it has a custom
         * implementation within IonTabBar.tsx. Calling onClick within this
         * component would result in duplicate handler calls.
         */
        const _a = this.props, rest = tslib.__rest(_a, ["onClick"]);
        return (React__default["default"].createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest)));
    }
    static get displayName() {
        return 'IonTabButton';
    }
})();

class IonTabBarUnwrapped extends React__default["default"].PureComponent {
    constructor(props) {
        super(props);
        this.setActiveTabOnContext = (_tab) => { };
        const tabs = {};
        React__default["default"].Children.forEach(props.children, (child) => {
            var _a, _b, _c, _d;
            if (child != null &&
                typeof child === 'object' &&
                child.props &&
                (child.type === IonTabButton || child.type.isTabButton)) {
                tabs[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href,
                    originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname)
                        ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : undefined,
                    currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname)
                        ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : undefined,
                };
            }
        });
        this.state = {
            tabs,
        };
        this.onTabButtonClick = this.onTabButtonClick.bind(this);
        this.renderTabButton = this.renderTabButton.bind(this);
        this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
        this.selectTab = this.selectTab.bind(this);
    }
    componentDidMount() {
        const tabs = this.state.tabs;
        const tabKeys = Object.keys(tabs);
        const activeTab = tabKeys.find((key) => {
            const href = tabs[key].originalHref;
            return this.props.routeInfo.pathname.startsWith(href);
        });
        if (activeTab) {
            this.setState({
                activeTab,
            });
        }
    }
    componentDidUpdate() {
        if (this.state.activeTab) {
            this.setActiveTabOnContext(this.state.activeTab);
        }
    }
    selectTab(tab) {
        const tabUrl = this.state.tabs[tab];
        if (tabUrl) {
            this.onTabButtonClick(new CustomEvent('ionTabButtonClick', {
                detail: {
                    href: tabUrl.currentHref,
                    tab,
                    selected: tab === this.state.activeTab,
                    routeOptions: undefined,
                },
            }));
            return true;
        }
        return false;
    }
    static getDerivedStateFromProps(props, state) {
        var _a, _b, _c;
        const tabs = Object.assign({}, state.tabs);
        const tabKeys = Object.keys(state.tabs);
        const activeTab = tabKeys.find((key) => {
            const href = state.tabs[key].originalHref;
            return props.routeInfo.pathname.startsWith(href);
        });
        // Check to see if the tab button href has changed, and if so, update it in the tabs state
        React__default["default"].Children.forEach(props.children, (child) => {
            if (child != null &&
                typeof child === 'object' &&
                child.props &&
                (child.type === IonTabButton || child.type.isTabButton)) {
                const tab = tabs[child.props.tab];
                if (!tab || tab.originalHref !== child.props.href) {
                    tabs[child.props.tab] = {
                        originalHref: child.props.href,
                        currentHref: child.props.href,
                        originalRouteOptions: child.props.routeOptions,
                        currentRouteOptions: child.props.routeOptions,
                    };
                }
            }
        });
        const { activeTab: prevActiveTab } = state;
        if (activeTab && prevActiveTab) {
            const prevHref = state.tabs[prevActiveTab].currentHref;
            const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
            if (activeTab !== prevActiveTab ||
                prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ||
                prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
                tabs[activeTab] = {
                    originalHref: tabs[activeTab].originalHref,
                    currentHref: props.routeInfo.pathname + (props.routeInfo.search || ''),
                    originalRouteOptions: tabs[activeTab].originalRouteOptions,
                    currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions,
                };
                if (props.routeInfo.routeAction === 'pop' && activeTab !== prevActiveTab) {
                    // If navigating back and the tabs change, set the prev tab back to its original href
                    tabs[prevActiveTab] = {
                        originalHref: tabs[prevActiveTab].originalHref,
                        currentHref: tabs[prevActiveTab].originalHref,
                        originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
                        currentRouteOptions: tabs[prevActiveTab].currentRouteOptions,
                    };
                }
            }
        }
        activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
        return {
            activeTab,
            tabs,
        };
    }
    onTabButtonClick(e, onClickFn) {
        const tappedTab = this.state.tabs[e.detail.tab];
        const originalHref = tappedTab.originalHref;
        const currentHref = e.detail.href;
        const { activeTab: prevActiveTab } = this.state;
        if (onClickFn) {
            /**
             * If the user provides an onClick function, we call it
             * with the original event.
             */
            onClickFn(e);
        }
        // this.props.onSetCurrentTab(e.detail.tab, this.props.routeInfo);
        // Clicking the current tab will bring you back to the original href
        if (prevActiveTab === e.detail.tab) {
            if (originalHref !== currentHref) {
                this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);
            }
        }
        else {
            if (this.props.onIonTabsWillChange) {
                this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', { detail: { tab: e.detail.tab } }));
            }
            if (this.props.onIonTabsDidChange) {
                this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', { detail: { tab: e.detail.tab } }));
            }
            this.setActiveTabOnContext(e.detail.tab);
            this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);
        }
    }
    renderTabButton(activeTab) {
        return (child) => {
            var _a, _b;
            if (child != null &&
                child.props &&
                (child.type === IonTabButton || child.type.isTabButton)) {
                const href = child.props.tab === activeTab
                    ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
                const routeOptions = child.props.tab === activeTab
                    ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
                return React__default["default"].cloneElement(child, {
                    href,
                    routeOptions,
                    onClick: (ev) => this.onTabButtonClick(ev, child.props.onClick),
                });
            }
            return null;
        };
    }
    render() {
        const { activeTab } = this.state;
        return (React__default["default"].createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), React__default["default"].Children.map(this.props.children, this.renderTabButton(activeTab))));
    }
    static get contextType() {
        return NavContext;
    }
}
const IonTabBarContainer = React__default["default"].memo((_a) => {
    var { forwardedRef } = _a, props = tslib.__rest(_a, ["forwardedRef"]);
    const context = React.useContext(NavContext);
    return (React__default["default"].createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children));
});
const IonTabBar = createForwardRef(IonTabBarContainer, 'IonTabBar');

class IonTabsElement extends HTMLElementSSR {
    constructor() {
        super();
    }
}
if (typeof window !== 'undefined' && window.customElements) {
    const element = window.customElements.get('ion-tabs');
    if (!element) {
        window.customElements.define('ion-tabs', IonTabsElement);
    }
}
const hostStyles = {
    display: 'flex',
    position: 'absolute',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    flexDirection: 'column',
    width: '100%',
    height: '100%',
    contain: 'layout size style',
};
const tabsInner = {
    position: 'relative',
    flex: 1,
    contain: 'layout size style',
};
const IonTabs = /*@__PURE__*/ (() => class extends React__default["default"].Component {
    constructor(props) {
        super(props);
        this.routerOutletRef = React__default["default"].createRef();
        this.tabBarRef = React__default["default"].createRef();
        this.ionTabContextState = {
            activeTab: undefined,
            selectTab: () => false,
        };
    }
    componentDidMount() {
        if (this.tabBarRef.current) {
            // Grab initial value
            this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;
            // Override method
            this.tabBarRef.current.setActiveTabOnContext = (tab) => {
                this.ionTabContextState.activeTab = tab;
            };
            this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;
        }
    }
    render() {
        let outlet;
        let tabBar;
        const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = tslib.__rest(_a, ["className", "onIonTabsDidChange", "onIonTabsWillChange"]);
        const children = typeof this.props.children === 'function'
            ? this.props.children(this.ionTabContextState)
            : this.props.children;
        React__default["default"].Children.forEach(children, (child) => {
            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {
                return;
            }
            if (child.type === IonRouterOutlet || child.type.isRouterOutlet) {
                outlet = React__default["default"].cloneElement(child);
            }
            else if (child.type === React.Fragment && child.props.children[0].type === IonRouterOutlet) {
                outlet = child.props.children[0];
            }
            let childProps = {
                ref: this.tabBarRef
            };
            /**
             * Only pass these props
             * down from IonTabs to IonTabBar
             * if they are defined, otherwise
             * if you have a handler set on
             * IonTabBar it will be overridden.
             */
            if (onIonTabsDidChange !== undefined) {
                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });
            }
            if (onIonTabsWillChange !== undefined) {
                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });
            }
            if (child.type === IonTabBar || child.type.isTabBar) {
                tabBar = React__default["default"].cloneElement(child, childProps);
            }
            else if (child.type === React.Fragment &&
                (child.props.children[1].type === IonTabBar || child.props.children[1].type.isTabBar)) {
                tabBar = React__default["default"].cloneElement(child.props.children[1], childProps);
            }
        });
        if (!outlet) {
            throw new Error('IonTabs must contain an IonRouterOutlet');
        }
        if (!tabBar) {
            throw new Error('IonTabs needs a IonTabBar');
        }
        return (React__default["default"].createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? (React__default["default"].createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo }, props),
            React__default["default"].createElement("ion-tabs", { className: "ion-tabs", style: hostStyles },
                tabBar.props.slot === 'top' ? tabBar : null,
                React__default["default"].createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet),
                tabBar.props.slot === 'bottom' ? tabBar : null))) : (React__default["default"].createElement("div", Object.assign({ className: className ? `${className}` : 'ion-tabs' }, props, { style: hostStyles }),
            tabBar.props.slot === 'top' ? tabBar : null,
            React__default["default"].createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet),
            tabBar.props.slot === 'bottom' ? tabBar : null))));
    }
    static get contextType() {
        return NavContext;
    }
})();

const IonBackButton = /*@__PURE__*/ (() => class extends React__default["default"].Component {
    constructor() {
        super(...arguments);
        this.clickButton = (e) => {
            /**
             * If ion-back-button is being used inside
             * of ion-nav then we should not interact with
             * the router.
             */
            if (e.target && e.target.closest('ion-nav') !== null) {
                return;
            }
            const { defaultHref, routerAnimation } = this.props;
            if (this.context.hasIonicRouter()) {
                e.stopPropagation();
                this.context.goBack(defaultHref, routerAnimation);
            }
            else if (defaultHref !== undefined) {
                window.location.href = defaultHref;
            }
        };
    }
    render() {
        return React__default["default"].createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));
    }
    static get displayName() {
        return 'IonBackButton';
    }
    static get contextType() {
        return NavContext;
    }
})();

class IonIconContainer extends React__default["default"].PureComponent {
    constructor(props) {
        super(props);
        if (this.props.name) {
            console.warn('In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
        }
    }
    render() {
        var _a, _b;
        const _c = this.props, { icon, ios, md } = _c, rest = tslib.__rest(_c, ["icon", "ios", "md"]);
        let iconToUse;
        if (ios || md) {
            if (isPlatform('ios')) {
                iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
            }
            else {
                iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
            }
        }
        else {
            iconToUse = icon;
        }
        return (React__default["default"].createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children));
    }
    static get contextType() {
        return NavContext;
    }
}
const IonIcon = createForwardRef(IonIconContainer, 'IonIcon');

class IonRoute extends React__default["default"].PureComponent {
    render() {
        const IonRouteInner = this.context.getIonRoute();
        if (!this.context.hasIonicRouter() || !IonRoute) {
            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRoute>');
            return null;
        }
        return React__default["default"].createElement(IonRouteInner, Object.assign({}, this.props));
    }
    static get contextType() {
        return NavContext;
    }
}

class IonRedirect extends React__default["default"].PureComponent {
    render() {
        const IonRedirectInner = this.context.getIonRedirect();
        if (!this.context.hasIonicRouter() || !IonRedirect) {
            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRedirect>');
            return null;
        }
        return React__default["default"].createElement(IonRedirectInner, Object.assign({}, this.props));
    }
    static get contextType() {
        return NavContext;
    }
}

const IonRouterContext = React__default["default"].createContext({
    routeInfo: undefined,
    push: () => {
        throw new Error('An Ionic Router is required for IonRouterContext');
    },
    back: () => {
        throw new Error('An Ionic Router is required for IonRouterContext');
    },
    canGoBack: () => {
        throw new Error('An Ionic Router is required for IonRouterContext');
    },
    nativeBack: () => {
        throw new Error('An Ionic Router is required for IonRouterContext');
    },
});
/**
 * A hook for more direct control over routing in an Ionic React application. Allows you to pass additional meta-data to the router before the call to the native router.
 */
function useIonRouter() {
    const context = React.useContext(IonRouterContext);
    return React.useMemo(() => ({
        back: context.back,
        push: context.push,
        goBack: context.back,
        canGoBack: context.canGoBack,
        routeInfo: context.routeInfo,
    }), [context.back, context.push, context.canGoBack, context.routeInfo]);
}

class CreateAnimation extends React__default["default"].PureComponent {
    constructor(props) {
        super(props);
        this.nodes = new Map();
        this.animation = components.createAnimation(props.id);
    }
    setupAnimation(props) {
        const animation = this.animation;
        if (this.nodes.size > 0) {
            animation.addElement(Array.from(this.nodes.values()));
        }
        checkConfig(animation, props);
        checkPlayback(animation, props);
    }
    componentDidMount() {
        const props = this.props;
        this.setupAnimation(props);
    }
    componentDidUpdate(prevProps) {
        const animation = this.animation;
        const props = this.props;
        checkConfig(animation, props, prevProps);
        checkProgress(animation, props, prevProps);
        checkPlayback(animation, props, prevProps);
    }
    render() {
        const { children } = this.props;
        return (React__default["default"].createElement(React__default["default"].Fragment, null, React__default["default"].Children.map(children, (child, id) => React__default["default"].cloneElement(child, { ref: (el) => this.nodes.set(id, el) }))));
    }
}
const checkConfig = (animation, currentProps = {}, prevProps = {}) => {
    const reservedProps = [
        'children',
        'progressStart',
        'progressStep',
        'progressEnd',
        'pause',
        'stop',
        'destroy',
        'play',
        'from',
        'to',
        'fromTo',
        'onFinish',
    ];
    for (const key in currentProps) {
        if (currentProps.hasOwnProperty(key) &&
            !reservedProps.includes(key) &&
            currentProps[key] !== prevProps[key]) {
            animation[key](currentProps[key]);
        }
    }
    const fromValues = currentProps.from;
    if (fromValues && fromValues !== prevProps.from) {
        const values = Array.isArray(fromValues) ? fromValues : [fromValues];
        values.forEach((val) => animation.from(val.property, val.value));
    }
    const toValues = currentProps.to;
    if (toValues && toValues !== prevProps.to) {
        const values = Array.isArray(toValues) ? toValues : [toValues];
        values.forEach((val) => animation.to(val.property, val.value));
    }
    const fromToValues = currentProps.fromTo;
    if (fromToValues && fromToValues !== prevProps.fromTo) {
        const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
        values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));
    }
    const onFinishValues = currentProps.onFinish;
    if (onFinishValues && onFinishValues !== prevProps.onFinish) {
        const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
        values.forEach((val) => animation.onFinish(val.callback, val.opts));
    }
};
const checkProgress = (animation, currentProps = {}, prevProps = {}) => {
    var _a, _b, _c, _d, _e;
    const { progressStart, progressStep, progressEnd } = currentProps;
    if (progressStart &&
        (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) ||
            ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
        animation.progressStart(progressStart.forceLinearEasing, progressStart.step);
    }
    if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
        animation.progressStep(progressStep.step);
    }
    if (progressEnd &&
        (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) ||
            ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) ||
            (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
        animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
    }
};
const checkPlayback = (animation, currentProps = {}, prevProps = {}) => {
    if (!prevProps.play && currentProps.play) {
        animation.play();
    }
    if (!prevProps.pause && currentProps.pause) {
        animation.pause();
    }
    if (!prevProps.stop && currentProps.stop) {
        animation.stop();
    }
    if (!prevProps.destroy && currentProps.destroy) {
        animation.destroy();
    }
};

function useController(displayName, controller, defineCustomElement) {
    const overlayRef = React.useRef();
    const didDismissEventName = React.useMemo(() => `on${displayName}DidDismiss`, [displayName]);
    const didPresentEventName = React.useMemo(() => `on${displayName}DidPresent`, [displayName]);
    const willDismissEventName = React.useMemo(() => `on${displayName}WillDismiss`, [displayName]);
    const willPresentEventName = React.useMemo(() => `on${displayName}WillPresent`, [displayName]);
    defineCustomElement();
    const present = React.useCallback(async (options) => {
        if (overlayRef.current) {
            return;
        }
        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = tslib.__rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
        const handleDismiss = (event) => {
            if (onDidDismiss) {
                onDidDismiss(event);
            }
            overlayRef.current = undefined;
        };
        overlayRef.current = await controller.create(Object.assign({}, rest));
        attachProps(overlayRef.current, {
            [didDismissEventName]: handleDismiss,
            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),
        });
        overlayRef.current.present();
    }, [controller]);
    const dismiss = React.useCallback(async () => {
        overlayRef.current && (await overlayRef.current.dismiss());
        overlayRef.current = undefined;
    }, []);
    return {
        present,
        dismiss,
    };
}

/**
 * A hook for presenting/dismissing an IonActionSheet component
 * @returns Returns the present and dismiss methods in an array
 */
function useIonActionSheet() {
    const controller = useController('IonActionSheet', components.actionSheetController, ionActionSheet_js.defineCustomElement);
    const present = React.useCallback((buttonsOrOptions, header) => {
        if (Array.isArray(buttonsOrOptions)) {
            return controller.present({
                buttons: buttonsOrOptions,
                header,
            });
        }
        else {
            return controller.present(buttonsOrOptions);
        }
    }, [controller.present]);
    return [present, controller.dismiss];
}

/**
 * A hook for presenting/dismissing an IonAlert component
 * @returns Returns the present and dismiss methods in an array
 */
function useIonAlert() {
    const controller = useController('IonAlert', components.alertController, ionAlert_js.defineCustomElement);
    const present = React.useCallback((messageOrOptions, buttons) => {
        if (typeof messageOrOptions === 'string') {
            return controller.present({
                message: messageOrOptions,
                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],
            });
        }
        else {
            return controller.present(messageOrOptions);
        }
    }, [controller.present]);
    return [present, controller.dismiss];
}

/**
 * A hook for presenting/dismissing an IonToast component
 * @returns Returns the present and dismiss methods in an array
 */
function useIonToast() {
    const controller = useController('IonToast', components.toastController, ionToast_js.defineCustomElement);
    const present = React.useCallback((messageOrOptions, duration) => {
        if (typeof messageOrOptions === 'string') {
            return controller.present({
                message: messageOrOptions,
                duration
            });
        }
        else {
            return controller.present(messageOrOptions);
        }
    }, [controller.present]);
    return [
        present,
        controller.dismiss
    ];
}

const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return id.toString();
};

function useOverlay(displayName, controller, defineCustomElement, component, componentProps) {
    const overlayRef = React.useRef();
    const containerElRef = React.useRef();
    const didDismissEventName = React.useMemo(() => `on${displayName}DidDismiss`, [displayName]);
    const didPresentEventName = React.useMemo(() => `on${displayName}DidPresent`, [displayName]);
    const willDismissEventName = React.useMemo(() => `on${displayName}WillDismiss`, [displayName]);
    const willPresentEventName = React.useMemo(() => `on${displayName}WillPresent`, [displayName]);
    const [isOpen, setIsOpen] = React.useState(false);
    const ionContext = React.useContext(IonContext);
    const [overlayId] = React.useState(generateId('overlay'));
    defineCustomElement();
    React.useEffect(() => {
        if (isOpen && component && containerElRef.current) {
            if (React__default["default"].isValidElement(component)) {
                ionContext.addOverlay(overlayId, component, containerElRef.current);
            }
            else {
                const element = React.createElement(component, componentProps);
                ionContext.addOverlay(overlayId, element, containerElRef.current);
            }
        }
    }, [component, containerElRef.current, isOpen, componentProps]);
    const present = React.useCallback(async (options) => {
        if (overlayRef.current) {
            return;
        }
        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = tslib.__rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
        if (typeof document !== 'undefined') {
            containerElRef.current = document.createElement('div');
        }
        overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));
        attachProps(overlayRef.current, {
            [didDismissEventName]: handleDismiss,
            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),
        });
        overlayRef.current.present();
        setIsOpen(true);
        function handleDismiss(event) {
            if (onDidDismiss) {
                onDidDismiss(event);
            }
            overlayRef.current = undefined;
            containerElRef.current = undefined;
            setIsOpen(false);
            ionContext.removeOverlay(overlayId);
        }
    }, []);
    const dismiss = React.useCallback(async (data, role) => {
        overlayRef.current && (await overlayRef.current.dismiss(data, role));
        overlayRef.current = undefined;
        containerElRef.current = undefined;
    }, []);
    return {
        present,
        dismiss,
    };
}

/**
 * A hook for presenting/dismissing an IonModal component
 * @param component The component that the modal will show. Can be a React Component, a functional component, or a JSX Element
 * @param componentProps The props that will be passed to the component, if required
 * @returns Returns the present and dismiss methods in an array
 */
function useIonModal(component, componentProps) {
    const controller = useOverlay('IonModal', components.modalController, ionModal_js.defineCustomElement, component, componentProps);
    const present = React.useCallback((options = {}) => {
        controller.present(options);
    }, [controller.present]);
    return [present, controller.dismiss];
}

/**
 * A hook for presenting/dismissing an IonPicker component
 * @param component The component that the popover will show. Can be a React Component, a functional component, or a JSX Element
 * @param componentProps The props that will be passed to the component, if required
 * @returns Returns the present and dismiss methods in an array
 */
function useIonPopover(component, componentProps) {
    const controller = useOverlay('IonPopover', components.popoverController, ionPopover_js.defineCustomElement, component, componentProps);
    const present = React.useCallback((options = {}) => {
        controller.present(options);
    }, [controller.present]);
    return [
        present,
        controller.dismiss
    ];
}

/**
 * A hook for presenting/dismissing an IonPicker component
 * @returns Returns the present and dismiss methods in an array
 */
function useIonPicker() {
    const controller = useController('IonPicker', components.pickerController, ionPicker_js.defineCustomElement);
    const present = React.useCallback((columnsOrOptions, buttons) => {
        if (Array.isArray(columnsOrOptions)) {
            return controller.present({
                columns: columnsOrOptions,
                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],
            });
        }
        else {
            return controller.present(columnsOrOptions);
        }
    }, [controller.present]);
    return [present, controller.dismiss];
}

/**
 * A hook for presenting/dismissing an IonLoading component
 * @returns Returns the present and dismiss methods in an array
 */
function useIonLoading() {
    const controller = useController('IonLoading', components.loadingController, ionLoading_js.defineCustomElement);
    const present = React.useCallback((messageOrOptions = {}, duration, spinner) => {
        if (typeof messageOrOptions === 'string') {
            return controller.present({
                message: messageOrOptions,
                duration,
                spinner,
            });
        }
        else {
            return controller.present(messageOrOptions);
        }
    }, [controller.present]);
    return [present, controller.dismiss];
}

const setupIonicReact = (config = {}) => {
    /**
     * By default Ionic Framework hides elements that
     * are not hydrated, but in the CE build there is no
     * hydration.
     * TODO FW-2797: Remove when all integrations have been
     * migrated to CE build.
     */
    if (typeof document !== 'undefined') {
        document.documentElement.classList.add('ion-ce');
    }
    components.initialize(Object.assign({}, config));
};

const RouteManagerContext = /*@__PURE__*/ React__default["default"].createContext({
    addViewItem: () => undefined,
    canGoBack: () => undefined,
    clearOutlet: () => undefined,
    createViewItem: () => undefined,
    findViewItemByPathname: () => undefined,
    findLeavingViewItemByRouteInfo: () => undefined,
    findViewItemByRouteInfo: () => undefined,
    getChildrenToRender: () => undefined,
    goBack: () => undefined,
    unMountViewItem: () => undefined,
});

class ViewLifeCycleManager extends React__default["default"].Component {
    constructor(props) {
        super(props);
        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
        this._isMounted = false;
        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
            if (!this.props.mount) {
                if (this._isMounted) {
                    this.setState({
                        show: false,
                    }, () => this.props.removeView());
                }
            }
        });
        this.state = {
            show: true,
        };
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
    }
    render() {
        const { show } = this.state;
        return (React__default["default"].createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));
    }
}

// const RESTRICT_SIZE = 100;
class LocationHistory {
    constructor() {
        this.locationHistory = [];
        this.tabHistory = {};
    }
    add(routeInfo) {
        if (routeInfo.routeAction === 'push' || routeInfo.routeAction == null) {
            this._add(routeInfo);
        }
        else if (routeInfo.routeAction === 'pop') {
            this._pop(routeInfo);
        }
        else if (routeInfo.routeAction === 'replace') {
            this._replace(routeInfo);
        }
        if (routeInfo.routeDirection === 'root') {
            this._clear();
            this._add(routeInfo);
        }
    }
    clearTabStack(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
            routeInfos.forEach((ri) => {
                this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);
            });
            this.tabHistory[tab] = [];
        }
    }
    update(routeInfo) {
        const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);
        if (locationIndex > -1) {
            this.locationHistory.splice(locationIndex, 1, routeInfo);
        }
        const tabArray = this.tabHistory[routeInfo.tab || ''];
        if (tabArray) {
            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);
            if (tabIndex > -1) {
                tabArray.splice(tabIndex, 1, routeInfo);
            }
            else {
                tabArray.push(routeInfo);
            }
        }
        else if (routeInfo.tab) {
            this.tabHistory[routeInfo.tab] = [routeInfo];
        }
    }
    _add(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
            // If the latest routeInfo is the same (going back and forth between tabs), replace it
            if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
                routeInfos.pop();
            }
            routeInfos.push(routeInfo);
        }
        this.locationHistory.push(routeInfo);
    }
    _areRoutesEqual(route1, route2) {
        if (!route1 || !route2) {
            return false;
        }
        return route1.pathname === route2.pathname && route1.search === route2.search;
    }
    _pop(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
            // Pop the previous route
            routeInfos.pop();
            // Replace the current route with an updated version
            routeInfos.pop();
            routeInfos.push(routeInfo);
        }
        // Pop the previous route
        this.locationHistory.pop();
        // Replace the current route with an updated version
        this.locationHistory.pop();
        this.locationHistory.push(routeInfo);
    }
    _replace(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        routeInfos && routeInfos.pop();
        this.locationHistory.pop();
        this._add(routeInfo);
    }
    _clear() {
        const keys = Object.keys(this.tabHistory);
        keys.forEach((k) => (this.tabHistory[k] = []));
        this.locationHistory = [];
    }
    _getRouteInfosByKey(key) {
        let routeInfos;
        if (key) {
            routeInfos = this.tabHistory[key];
            if (!routeInfos) {
                routeInfos = this.tabHistory[key] = [];
            }
        }
        return routeInfos;
    }
    getFirstRouteInfoForTab(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
            return routeInfos[0];
        }
        return undefined;
    }
    getCurrentRouteInfoForTab(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
            return routeInfos[routeInfos.length - 1];
        }
        return undefined;
    }
    findLastLocation(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
            for (let i = routeInfos.length - 2; i >= 0; i--) {
                const ri = routeInfos[i];
                if (ri) {
                    if (ri.pathname === routeInfo.pushedByRoute) {
                        return ri;
                    }
                }
            }
        }
        for (let i = this.locationHistory.length - 2; i >= 0; i--) {
            const ri = this.locationHistory[i];
            if (ri) {
                if (ri.pathname === routeInfo.pushedByRoute) {
                    return ri;
                }
            }
        }
        return undefined;
    }
    previous() {
        return (this.locationHistory[this.locationHistory.length - 2] ||
            this.locationHistory[this.locationHistory.length - 1]);
    }
    current() {
        return this.locationHistory[this.locationHistory.length - 1];
    }
    canGoBack() {
        return this.locationHistory.length > 1;
    }
}

class NavManager extends React__default["default"].PureComponent {
    constructor(props) {
        super(props);
        this._isMounted = false;
        this.ionRouterContextValue = {
            push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
                this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
            },
            back: (animationBuilder) => {
                this.goBack(undefined, animationBuilder);
            },
            canGoBack: () => this.props.locationHistory.canGoBack(),
            nativeBack: () => this.props.onNativeBack(),
            routeInfo: this.props.routeInfo,
        };
        this.state = {
            goBack: this.goBack.bind(this),
            hasIonicRouter: () => true,
            navigate: this.navigate.bind(this),
            getIonRedirect: this.getIonRedirect.bind(this),
            getIonRoute: this.getIonRoute.bind(this),
            getStackManager: this.getStackManager.bind(this),
            getPageManager: this.getPageManager.bind(this),
            routeInfo: this.props.routeInfo,
            setCurrentTab: this.props.onSetCurrentTab,
            changeTab: this.props.onChangeTab,
            resetTab: this.props.onResetTab,
        };
        if (typeof document !== 'undefined') {
            this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
            document.addEventListener('ionBackButton', this.handleHardwareBackButton);
        }
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        if (typeof document !== 'undefined') {
            document.removeEventListener('ionBackButton', this.handleHardwareBackButton);
            this._isMounted = false;
        }
    }
    handleHardwareBackButton(e) {
        e.detail.register(0, (processNextHandler) => {
            if (this._isMounted) {
                this.nativeGoBack();
                processNextHandler();
            }
        });
    }
    goBack(route, animationBuilder) {
        this.props.onNavigateBack(route, animationBuilder);
    }
    nativeGoBack() {
        this.props.onNativeBack();
    }
    navigate(path, direction = 'forward', action = 'push', animationBuilder, options, tab) {
        this.props.onNavigate(path, action, direction, animationBuilder, options, tab);
    }
    getPageManager() {
        return PageManager;
    }
    getIonRedirect() {
        return this.props.ionRedirect;
    }
    getIonRoute() {
        return this.props.ionRoute;
    }
    getStackManager() {
        return this.props.stackManager;
    }
    render() {
        return (React__default["default"].createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },
            React__default["default"].createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)));
    }
}

class ViewStacks {
    constructor() {
        this.viewStacks = {};
        this.add = this.add.bind(this);
        this.clear = this.clear.bind(this);
        this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
        this.remove = this.remove.bind(this);
    }
    add(viewItem) {
        const { outletId } = viewItem;
        if (!this.viewStacks[outletId]) {
            this.viewStacks[outletId] = [viewItem];
        }
        else {
            this.viewStacks[outletId].push(viewItem);
        }
    }
    clear(outletId) {
        // Give some time for the leaving views to transition before removing
        return setTimeout(() => {
            delete this.viewStacks[outletId];
        }, 500);
    }
    getViewItemsForOutlet(outletId) {
        return this.viewStacks[outletId] || [];
    }
    remove(viewItem) {
        const { outletId } = viewItem;
        const viewStack = this.viewStacks[outletId];
        if (viewStack) {
            const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);
            if (viewItemToRemove) {
                viewItemToRemove.mount = false;
                this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);
            }
        }
    }
    getStackIds() {
        return Object.keys(this.viewStacks);
    }
    getAllViewItems() {
        const keys = this.getStackIds();
        const viewItems = [];
        keys.forEach((k) => {
            viewItems.push(...this.viewStacks[k]);
        });
        return viewItems;
    }
}

Object.defineProperty(exports, 'IonicSafeString', {
    enumerable: true,
    get: function () { return components.IonicSafeString; }
});
Object.defineProperty(exports, 'IonicSlides', {
    enumerable: true,
    get: function () { return components.IonicSlides; }
});
Object.defineProperty(exports, 'IonicSwiper', {
    enumerable: true,
    get: function () { return components.IonicSwiper; }
});
Object.defineProperty(exports, 'createAnimation', {
    enumerable: true,
    get: function () { return components.createAnimation; }
});
Object.defineProperty(exports, 'createGesture', {
    enumerable: true,
    get: function () { return components.createGesture; }
});
Object.defineProperty(exports, 'getTimeGivenProgression', {
    enumerable: true,
    get: function () { return components.getTimeGivenProgression; }
});
Object.defineProperty(exports, 'iosTransitionAnimation', {
    enumerable: true,
    get: function () { return components.iosTransitionAnimation; }
});
Object.defineProperty(exports, 'mdTransitionAnimation', {
    enumerable: true,
    get: function () { return components.mdTransitionAnimation; }
});
exports.CreateAnimation = CreateAnimation;
exports.DefaultIonLifeCycleContext = DefaultIonLifeCycleContext;
exports.IonAccordion = IonAccordion;
exports.IonAccordionGroup = IonAccordionGroup;
exports.IonActionSheet = IonActionSheet;
exports.IonAlert = IonAlert;
exports.IonApp = IonApp;
exports.IonAvatar = IonAvatar;
exports.IonBackButton = IonBackButton;
exports.IonBackdrop = IonBackdrop;
exports.IonBadge = IonBadge;
exports.IonBreadcrumb = IonBreadcrumb;
exports.IonBreadcrumbs = IonBreadcrumbs;
exports.IonButton = IonButton;
exports.IonButtons = IonButtons;
exports.IonCard = IonCard;
exports.IonCardContent = IonCardContent;
exports.IonCardHeader = IonCardHeader;
exports.IonCardSubtitle = IonCardSubtitle;
exports.IonCardTitle = IonCardTitle;
exports.IonCheckbox = IonCheckbox;
exports.IonChip = IonChip;
exports.IonCol = IonCol;
exports.IonContent = IonContent;
exports.IonDatetime = IonDatetime;
exports.IonDatetimeButton = IonDatetimeButton;
exports.IonFab = IonFab;
exports.IonFabButton = IonFabButton;
exports.IonFabList = IonFabList;
exports.IonFooter = IonFooter;
exports.IonGrid = IonGrid;
exports.IonHeader = IonHeader;
exports.IonIcon = IonIcon;
exports.IonImg = IonImg;
exports.IonInfiniteScroll = IonInfiniteScroll;
exports.IonInfiniteScrollContent = IonInfiniteScrollContent;
exports.IonInput = IonInput;
exports.IonItem = IonItem;
exports.IonItemDivider = IonItemDivider;
exports.IonItemGroup = IonItemGroup;
exports.IonItemOption = IonItemOption;
exports.IonItemOptions = IonItemOptions;
exports.IonItemSliding = IonItemSliding;
exports.IonLabel = IonLabel;
exports.IonLifeCycleContext = IonLifeCycleContext;
exports.IonList = IonList;
exports.IonListHeader = IonListHeader;
exports.IonLoading = IonLoading;
exports.IonMenu = IonMenu;
exports.IonMenuButton = IonMenuButton;
exports.IonMenuToggle = IonMenuToggle;
exports.IonModal = IonModal;
exports.IonNav = IonNav;
exports.IonNavLink = IonNavLink;
exports.IonNote = IonNote;
exports.IonPage = IonPage;
exports.IonPicker = IonPicker;
exports.IonPopover = IonPopover;
exports.IonProgressBar = IonProgressBar;
exports.IonRadio = IonRadio;
exports.IonRadioGroup = IonRadioGroup;
exports.IonRange = IonRange;
exports.IonRedirect = IonRedirect;
exports.IonRefresher = IonRefresher;
exports.IonRefresherContent = IonRefresherContent;
exports.IonReorder = IonReorder;
exports.IonReorderGroup = IonReorderGroup;
exports.IonRippleEffect = IonRippleEffect;
exports.IonRoute = IonRoute;
exports.IonRouterContext = IonRouterContext;
exports.IonRouterLink = IonRouterLink;
exports.IonRouterOutlet = IonRouterOutlet;
exports.IonRow = IonRow;
exports.IonSearchbar = IonSearchbar;
exports.IonSegment = IonSegment;
exports.IonSegmentButton = IonSegmentButton;
exports.IonSelect = IonSelect;
exports.IonSelectOption = IonSelectOption;
exports.IonSkeletonText = IonSkeletonText;
exports.IonSlide = IonSlide;
exports.IonSlides = IonSlides;
exports.IonSpinner = IonSpinner;
exports.IonSplitPane = IonSplitPane;
exports.IonTab = IonTab;
exports.IonTabBar = IonTabBar;
exports.IonTabButton = IonTabButton;
exports.IonTabs = IonTabs;
exports.IonTabsContext = IonTabsContext;
exports.IonText = IonText;
exports.IonTextarea = IonTextarea;
exports.IonThumbnail = IonThumbnail;
exports.IonTitle = IonTitle;
exports.IonToast = IonToast;
exports.IonToggle = IonToggle;
exports.IonToolbar = IonToolbar;
exports.IonVirtualScroll = IonVirtualScroll;
exports.LocationHistory = LocationHistory;
exports.NavContext = NavContext;
exports.NavManager = NavManager;
exports.RouteManagerContext = RouteManagerContext;
exports.StackContext = StackContext;
exports.ViewLifeCycleManager = ViewLifeCycleManager;
exports.ViewStacks = ViewStacks;
exports.generateId = generateId;
exports.getConfig = getConfig;
exports.getPlatforms = getPlatforms;
exports.isPlatform = isPlatform;
exports.setupIonicReact = setupIonicReact;
exports.useIonActionSheet = useIonActionSheet;
exports.useIonAlert = useIonAlert;
exports.useIonLoading = useIonLoading;
exports.useIonModal = useIonModal;
exports.useIonPicker = useIonPicker;
exports.useIonPopover = useIonPopover;
exports.useIonRouter = useIonRouter;
exports.useIonToast = useIonToast;
exports.useIonViewDidEnter = useIonViewDidEnter;
exports.useIonViewDidLeave = useIonViewDidLeave;
exports.useIonViewWillEnter = useIonViewWillEnter;
exports.useIonViewWillLeave = useIonViewWillLeave;
exports.withIonLifeCycle = withIonLifeCycle;
//# sourceMappingURL=index.js.map
