{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nvar wrappedFetch = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var request, fetchOptions, event, _ref$plugins, plugins, possiblePreloadResponse, failedFetchPlugins, originalRequest, _iterator, _step, plugin, pluginMethod, requestClone, pluginFilteredRequest, fetchResponse, _iterator2, _step2, _plugin, _iterator3, _step3, _plugin2;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          request = _ref.request, fetchOptions = _ref.fetchOptions, event = _ref.event, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n          if (typeof request === 'string') {\n            request = new Request(request);\n          }\n          // We *should* be able to call `await event.preloadResponse` even if it's\n          // undefined, but for some reason, doing so leads to errors in our Node unit\n          // tests. To work around that, explicitly check preloadResponse's value first.\n          if (!(event instanceof FetchEvent && event.preloadResponse)) {\n            _context.next = 9;\n            break;\n          }\n          _context.next = 5;\n          return event.preloadResponse;\n        case 5:\n          possiblePreloadResponse = _context.sent;\n          if (!possiblePreloadResponse) {\n            _context.next = 9;\n            break;\n          }\n          if (process.env.NODE_ENV !== 'production') {\n            logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n          }\n          return _context.abrupt(\"return\", possiblePreloadResponse);\n        case 9:\n          if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n              paramName: 'request',\n              expectedClass: Request,\n              moduleName: 'workbox-core',\n              className: 'fetchWrapper',\n              funcName: 'wrappedFetch'\n            });\n          }\n          failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */); // If there is a fetchDidFail plugin, we need to save a clone of the\n          // original request before it's either modified by a requestWillFetch\n          // plugin or before the original request's body is consumed via fetch().\n          originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n          _context.prev = 12;\n          _iterator = _createForOfIteratorHelper(plugins);\n          _context.prev = 14;\n          _iterator.s();\n        case 16:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 27;\n            break;\n          }\n          plugin = _step.value;\n          if (!(\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin)) {\n            _context.next = 25;\n            break;\n          }\n          pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n          requestClone = request.clone();\n          _context.next = 23;\n          return pluginMethod.call(plugin, {\n            request: requestClone,\n            event: event\n          });\n        case 23:\n          request = _context.sent;\n          if (process.env.NODE_ENV !== 'production') {\n            if (request) {\n              assert.isInstance(request, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                isReturnValueProblem: true\n              });\n            }\n          }\n        case 25:\n          _context.next = 16;\n          break;\n        case 27:\n          _context.next = 32;\n          break;\n        case 29:\n          _context.prev = 29;\n          _context.t0 = _context[\"catch\"](14);\n          _iterator.e(_context.t0);\n        case 32:\n          _context.prev = 32;\n          _iterator.f();\n          return _context.finish(32);\n        case 35:\n          _context.next = 40;\n          break;\n        case 37:\n          _context.prev = 37;\n          _context.t1 = _context[\"catch\"](12);\n          throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: _context.t1\n          });\n        case 40:\n          // The request can be altered by plugins with `requestWillFetch` making\n          // the original request (Most likely from a `fetch` event) to be different\n          // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n          pluginFilteredRequest = request.clone();\n          _context.prev = 41;\n          if (!(request.mode === 'navigate')) {\n            _context.next = 48;\n            break;\n          }\n          _context.next = 45;\n          return fetch(request);\n        case 45:\n          fetchResponse = _context.sent;\n          _context.next = 51;\n          break;\n        case 48:\n          _context.next = 50;\n          return fetch(request, fetchOptions);\n        case 50:\n          fetchResponse = _context.sent;\n        case 51:\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n          }\n          _iterator2 = _createForOfIteratorHelper(plugins);\n          _context.prev = 53;\n          _iterator2.s();\n        case 55:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 64;\n            break;\n          }\n          _plugin = _step2.value;\n          if (!(\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in _plugin)) {\n            _context.next = 62;\n            break;\n          }\n          _context.next = 60;\n          return _plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */].call(_plugin, {\n            event: event,\n            request: pluginFilteredRequest,\n            response: fetchResponse\n          });\n        case 60:\n          fetchResponse = _context.sent;\n          if (process.env.NODE_ENV !== 'production') {\n            if (fetchResponse) {\n              assert.isInstance(fetchResponse, Response, {\n                moduleName: 'Plugin',\n                funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                isReturnValueProblem: true\n              });\n            }\n          }\n        case 62:\n          _context.next = 55;\n          break;\n        case 64:\n          _context.next = 69;\n          break;\n        case 66:\n          _context.prev = 66;\n          _context.t2 = _context[\"catch\"](53);\n          _iterator2.e(_context.t2);\n        case 69:\n          _context.prev = 69;\n          _iterator2.f();\n          return _context.finish(69);\n        case 72:\n          return _context.abrupt(\"return\", fetchResponse);\n        case 75:\n          _context.prev = 75;\n          _context.t3 = _context[\"catch\"](41);\n          if (process.env.NODE_ENV !== 'production') {\n            logger.error(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t3);\n          }\n          _iterator3 = _createForOfIteratorHelper(failedFetchPlugins);\n          _context.prev = 79;\n          _iterator3.s();\n        case 81:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 87;\n            break;\n          }\n          _plugin2 = _step3.value;\n          _context.next = 85;\n          return _plugin2[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(_plugin2, {\n            error: _context.t3,\n            event: event,\n            originalRequest: originalRequest.clone(),\n            request: pluginFilteredRequest.clone()\n          });\n        case 85:\n          _context.next = 81;\n          break;\n        case 87:\n          _context.next = 92;\n          break;\n        case 89:\n          _context.prev = 89;\n          _context.t4 = _context[\"catch\"](79);\n          _iterator3.e(_context.t4);\n        case 92:\n          _context.prev = 92;\n          _iterator3.f();\n          return _context.finish(92);\n        case 95:\n          throw _context.t3;\n        case 96:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[12, 37], [14, 29, 32, 35], [41, 75], [53, 66, 69, 72], [79, 89, 92, 95]]);\n  }));\n  return function wrappedFetch(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":{"version":3,"names":["WorkboxError","logger","assert","getFriendlyURL","pluginUtils","wrappedFetch","request","fetchOptions","event","plugins","Request","FetchEvent","preloadResponse","possiblePreloadResponse","process","env","NODE_ENV","log","url","isInstance","paramName","expectedClass","moduleName","className","funcName","failedFetchPlugins","filter","originalRequest","length","clone","plugin","pluginMethod","requestClone","call","isReturnValueProblem","thrownError","pluginFilteredRequest","mode","fetch","fetchResponse","debug","status","response","Response","error","fetchWrapper"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/workbox-core/_private/fetchWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({ request, fetchOptions, event, plugins = [], }) => {\n    if (typeof request === 'string') {\n        request = new Request(request);\n    }\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n        if (possiblePreloadResponse) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Using a preloaded navigation response for ` +\n                    `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n            paramName: 'request',\n            expectedClass: Request,\n            moduleName: 'workbox-core',\n            className: 'fetchWrapper',\n            funcName: 'wrappedFetch',\n        });\n    }\n    const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */);\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = failedFetchPlugins.length > 0 ?\n        request.clone() : null;\n    try {\n        for (const plugin of plugins) {\n            if (\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin) {\n                const pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n                const requestClone = request.clone();\n                request = await pluginMethod.call(plugin, {\n                    request: requestClone,\n                    event,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (request) {\n                        assert.isInstance(request, Request, {\n                            moduleName: 'Plugin',\n                            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: err,\n        });\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n        let fetchResponse;\n        // See https://github.com/GoogleChrome/workbox/issues/1796\n        if (request.mode === 'navigate') {\n            fetchResponse = await fetch(request);\n        }\n        else {\n            fetchResponse = await fetch(request, fetchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' returned a response with ` +\n                `status '${fetchResponse.status}'.`);\n        }\n        for (const plugin of plugins) {\n            if (\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in plugin) {\n                fetchResponse = await plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */]\n                    .call(plugin, {\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (fetchResponse) {\n                        assert.isInstance(fetchResponse, Response, {\n                            moduleName: 'Plugin',\n                            funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n        return fetchResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n        for (const plugin of failedFetchPlugins) {\n            await plugin[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(plugin, {\n                error,\n                event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone(),\n            });\n        }\n        throw error;\n    }\n};\nconst fetchWrapper = {\n    fetch: wrappedFetch,\n};\nexport { fetchWrapper };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}