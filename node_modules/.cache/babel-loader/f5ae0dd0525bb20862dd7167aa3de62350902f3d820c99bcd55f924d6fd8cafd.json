{"ast":null,"code":"import _assertThisInitialized from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent } from '@stencil/core/internal/client';\nimport { c as componentOnReady, o as debounce } from './helpers.js';\nvar ROUTER_INTENT_NONE = 'root';\nvar ROUTER_INTENT_FORWARD = 'forward';\nvar ROUTER_INTENT_BACK = 'back';\n\n/** Join the non empty segments with \"/\". */\nvar generatePath = function generatePath(segments) {\n  var path = segments.filter(function (s) {\n    return s.length > 0;\n  }).join('/');\n  return '/' + path;\n};\nvar generateUrl = function generateUrl(segments, useHash, queryString) {\n  var url = generatePath(segments);\n  if (useHash) {\n    url = '#' + url;\n  }\n  if (queryString !== undefined) {\n    url += '?' + queryString;\n  }\n  return url;\n};\nvar writeSegments = function writeSegments(history, root, useHash, segments, direction, state, queryString) {\n  var url = generateUrl([].concat(_toConsumableArray(parsePath(root).segments), _toConsumableArray(segments)), useHash, queryString);\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  } else {\n    history.replaceState(state, '', url);\n  }\n};\n/**\n * Transforms a chain to a list of segments.\n *\n * Notes:\n * - parameter segments of the form :param are replaced with their value,\n * - null is returned when a value is missing for any parameter segment.\n */\nvar chainToSegments = function chainToSegments(chain) {\n  var segments = [];\n  var _iterator = _createForOfIteratorHelper(chain),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var route = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(route.segments),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var segment = _step2.value;\n          if (segment[0] === ':') {\n            var param = route.params && route.params[segment.slice(1)];\n            if (!param) {\n              return null;\n            }\n            segments.push(param);\n          } else if (segment !== '') {\n            segments.push(segment);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return segments;\n};\n/**\n * Removes the prefix segments from the path segments.\n *\n * Return:\n * - null when the path segments do not start with the passed prefix,\n * - the path segments after the prefix otherwise.\n */\nvar removePrefix = function removePrefix(prefix, segments) {\n  if (prefix.length > segments.length) {\n    return null;\n  }\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return segments;\n  }\n  for (var i = 0; i < prefix.length; i++) {\n    if (prefix[i] !== segments[i]) {\n      return null;\n    }\n  }\n  if (segments.length === prefix.length) {\n    return [''];\n  }\n  return segments.slice(prefix.length);\n};\nvar readSegments = function readSegments(loc, root, useHash) {\n  var prefix = parsePath(root).segments;\n  var pathname = useHash ? loc.hash.slice(1) : loc.pathname;\n  var segments = parsePath(pathname).segments;\n  return removePrefix(prefix, segments);\n};\n/**\n * Parses the path to:\n * - segments an array of '/' separated parts,\n * - queryString (undefined when no query string).\n */\nvar parsePath = function parsePath(path) {\n  var segments = [''];\n  var queryString;\n  if (path != null) {\n    var qsStart = path.indexOf('?');\n    if (qsStart > -1) {\n      queryString = path.substring(qsStart + 1);\n      path = path.substring(0, qsStart);\n    }\n    segments = path.split('/').map(function (s) {\n      return s.trim();\n    }).filter(function (s) {\n      return s.length > 0;\n    });\n    if (segments.length === 0) {\n      segments = [''];\n    }\n  }\n  return {\n    segments: segments,\n    queryString: queryString\n  };\n};\nvar printRoutes = function printRoutes(routes) {\n  console.group(\"[ion-core] ROUTES[\".concat(routes.length, \"]\"));\n  var _iterator3 = _createForOfIteratorHelper(routes),\n    _step3;\n  try {\n    var _loop = function _loop() {\n      var chain = _step3.value;\n      var segments = [];\n      chain.forEach(function (r) {\n        return segments.push.apply(segments, _toConsumableArray(r.segments));\n      });\n      var ids = chain.map(function (r) {\n        return r.id;\n      });\n      console.debug(\"%c \".concat(generatePath(segments)), 'font-weight: bold; padding-left: 20px', '=>\\t', \"(\".concat(ids.join(', '), \")\"));\n    };\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  console.groupEnd();\n};\nvar printRedirects = function printRedirects(redirects) {\n  console.group(\"[ion-core] REDIRECTS[\".concat(redirects.length, \"]\"));\n  var _iterator4 = _createForOfIteratorHelper(redirects),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var redirect = _step4.value;\n      if (redirect.to) {\n        console.debug('FROM: ', \"$c \".concat(generatePath(redirect.from)), 'font-weight: bold', ' TO: ', \"$c \".concat(generatePath(redirect.to.segments)), 'font-weight: bold');\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  console.groupEnd();\n};\n\n/**\n * Activates the passed route chain.\n *\n * There must be exactly one outlet per route entry in the chain.\n *\n * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.\n * setRouteId will create or select the view in the outlet.\n */\nvar _writeNavState = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(root, chain, direction, index) {\n    var changed,\n      animation,\n      outlet,\n      route,\n      result,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          changed = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;\n          animation = _args.length > 5 ? _args[5] : undefined;\n          _context.prev = 2;\n          // find next navigation outlet in the DOM\n          outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort\n          if (!(index >= chain.length || !outlet)) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", changed);\n        case 6:\n          _context.next = 8;\n          return new Promise(function (resolve) {\n            return componentOnReady(outlet, resolve);\n          });\n        case 8:\n          route = chain[index];\n          _context.next = 11;\n          return outlet.setRouteId(route.id, route.params, direction, animation);\n        case 11:\n          result = _context.sent;\n          // if the outlet changed the page, reset navigation to neutral (no direction)\n          // this means nested outlets will not animate\n          if (result.changed) {\n            direction = ROUTER_INTENT_NONE;\n            changed = true;\n          }\n          // recursively set nested outlets\n          _context.next = 15;\n          return _writeNavState(result.element, chain, direction, index + 1, changed, animation);\n        case 15:\n          changed = _context.sent;\n          if (!result.markVisible) {\n            _context.next = 19;\n            break;\n          }\n          _context.next = 19;\n          return result.markVisible();\n        case 19:\n          return _context.abrupt(\"return\", changed);\n        case 22:\n          _context.prev = 22;\n          _context.t0 = _context[\"catch\"](2);\n          console.error(_context.t0);\n          return _context.abrupt(\"return\", false);\n        case 26:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 22]]);\n  }));\n  return function writeNavState(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Recursively walks the outlet in the DOM.\n *\n * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.\n */\nvar readNavState = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(root) {\n    var ids, outlet, node, id;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          ids = [];\n          node = root; // eslint-disable-next-line no-cond-assign\n        case 2:\n          if (!(outlet = searchNavNode(node))) {\n            _context2.next = 15;\n            break;\n          }\n          _context2.next = 5;\n          return outlet.getRouteId();\n        case 5:\n          id = _context2.sent;\n          if (!id) {\n            _context2.next = 12;\n            break;\n          }\n          node = id.element;\n          id.element = undefined;\n          ids.push(id);\n          _context2.next = 13;\n          break;\n        case 12:\n          return _context2.abrupt(\"break\", 15);\n        case 13:\n          _context2.next = 2;\n          break;\n        case 15:\n          return _context2.abrupt(\"return\", {\n            ids: ids,\n            outlet: outlet\n          });\n        case 16:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function readNavState(_x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar waitUntilNavNode = function waitUntilNavNode() {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n  return new Promise(function (resolve) {\n    window.addEventListener('ionNavWillLoad', function () {\n      return resolve();\n    }, {\n      once: true\n    });\n  });\n};\n/** Selector for all the outlets supported by the router. */\nvar OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nvar searchNavNode = function searchNavNode(root) {\n  if (!root) {\n    return undefined;\n  }\n  if (root.matches(OUTLET_SELECTOR)) {\n    return root;\n  }\n  var outlet = root.querySelector(OUTLET_SELECTOR);\n  return outlet !== null && outlet !== void 0 ? outlet : undefined;\n};\n\n/**\n * Returns whether the given redirect matches the given path segments.\n *\n * A redirect matches when the segments of the path and redirect.from are equal.\n * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.\n * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].\n */\nvar matchesRedirect = function matchesRedirect(segments, redirect) {\n  var from = redirect.from,\n    to = redirect.to;\n  if (to === undefined) {\n    return false;\n  }\n  if (from.length > segments.length) {\n    return false;\n  }\n  for (var i = 0; i < from.length; i++) {\n    var expected = from[i];\n    if (expected === '*') {\n      return true;\n    }\n    if (expected !== segments[i]) {\n      return false;\n    }\n  }\n  return from.length === segments.length;\n};\n/** Returns the first redirect matching the path segments or undefined when no match found. */\nvar findRouteRedirect = function findRouteRedirect(segments, redirects) {\n  return redirects.find(function (redirect) {\n    return matchesRedirect(segments, redirect);\n  });\n};\nvar matchesIDs = function matchesIDs(ids, chain) {\n  var len = Math.min(ids.length, chain.length);\n  var score = 0;\n  for (var i = 0; i < len; i++) {\n    var routeId = ids[i];\n    var routeChain = chain[i];\n    // Skip results where the route id does not match the chain at the same index\n    if (routeId.id.toLowerCase() !== routeChain.id) {\n      break;\n    }\n    if (routeId.params) {\n      var routeIdParams = Object.keys(routeId.params);\n      // Only compare routes with the chain that have the same number of parameters.\n      if (routeIdParams.length === routeChain.segments.length) {\n        // Maps the route's params into a path based on the path variable names,\n        // to compare against the route chain format.\n        //\n        // Before:\n        // ```ts\n        // {\n        //  params: {\n        //    s1: 'a',\n        //    s2: 'b'\n        //  }\n        // }\n        // ```\n        //\n        // After:\n        // ```ts\n        // [':s1',':s2']\n        // ```\n        //\n        var pathWithParams = routeIdParams.map(function (key) {\n          return \":\".concat(key);\n        });\n        for (var j = 0; j < pathWithParams.length; j++) {\n          // Skip results where the path variable is not a match\n          if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {\n            break;\n          }\n          // Weight path matches for the same index higher.\n          score++;\n        }\n      }\n    }\n    // Weight id matches\n    score++;\n  }\n  return score;\n};\n/**\n * Matches the segments against the chain.\n *\n * Returns:\n * - null when there is no match,\n * - a chain with the params properties updated with the parameter segments on match.\n */\nvar matchesSegments = function matchesSegments(segments, chain) {\n  var inputSegments = new RouterSegments(segments);\n  var matchesDefault = false;\n  var allparams;\n  for (var i = 0; i < chain.length; i++) {\n    var chainSegments = chain[i].segments;\n    if (chainSegments[0] === '') {\n      matchesDefault = true;\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(chainSegments),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var segment = _step5.value;\n          var data = inputSegments.next();\n          // data param\n          if (segment[0] === ':') {\n            if (data === '') {\n              return null;\n            }\n            allparams = allparams || [];\n            var params = allparams[i] || (allparams[i] = {});\n            params[segment.slice(1)] = data;\n          } else if (data !== segment) {\n            return null;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      matchesDefault = false;\n    }\n  }\n  var matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;\n  if (!matches) {\n    return null;\n  }\n  if (allparams) {\n    return chain.map(function (route, i) {\n      return {\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, allparams[i]),\n        beforeEnter: route.beforeEnter,\n        beforeLeave: route.beforeLeave\n      };\n    });\n  }\n  return chain;\n};\n/**\n * Merges the route parameter objects.\n * Returns undefined when both parameters are undefined.\n */\nvar mergeParams = function mergeParams(a, b) {\n  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;\n};\n/**\n * Finds the best match for the ids in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the RouteIDs.\n * That is they contain both the componentProps of the <ion-route> and the parameter segment.\n */\nvar findChainForIDs = function findChainForIDs(ids, chains) {\n  var match = null;\n  var maxMatches = 0;\n  var _iterator6 = _createForOfIteratorHelper(chains),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var chain = _step6.value;\n      var score = matchesIDs(ids, chain);\n      if (score > maxMatches) {\n        match = chain;\n        maxMatches = score;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  if (match) {\n    return match.map(function (route, i) {\n      var _a;\n      return {\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params)\n      };\n    });\n  }\n  return null;\n};\n/**\n * Finds the best match for the segments in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the segments.\n * That is they contain both the componentProps of the <ion-route> and the parameter segments.\n */\nvar findChainForSegments = function findChainForSegments(segments, chains) {\n  var match = null;\n  var bestScore = 0;\n  var _iterator7 = _createForOfIteratorHelper(chains),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var chain = _step7.value;\n      var matchedChain = matchesSegments(segments, chain);\n      if (matchedChain !== null) {\n        var score = computePriority(matchedChain);\n        if (score > bestScore) {\n          bestScore = score;\n          match = matchedChain;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return match;\n};\n/**\n * Computes the priority of a chain.\n *\n * Parameter segments are given a lower priority over fixed segments.\n *\n * Considering the following 2 chains matching the path /path/to/page:\n * - /path/to/:where\n * - /path/to/page\n *\n * The second one will be given a higher priority because \"page\" is a fixed segment (vs \":where\", a parameter segment).\n */\nvar computePriority = function computePriority(chain) {\n  var score = 1;\n  var level = 1;\n  var _iterator8 = _createForOfIteratorHelper(chain),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var route = _step8.value;\n      var _iterator9 = _createForOfIteratorHelper(route.segments),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var segment = _step9.value;\n          if (segment[0] === ':') {\n            score += Math.pow(1, level);\n          } else if (segment !== '') {\n            score += Math.pow(2, level);\n          }\n          level++;\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return score;\n};\nvar RouterSegments = /*#__PURE__*/function () {\n  function RouterSegments(segments) {\n    _classCallCheck(this, RouterSegments);\n    this.segments = segments.slice();\n  }\n  _createClass(RouterSegments, [{\n    key: \"next\",\n    value: function next() {\n      if (this.segments.length > 0) {\n        return this.segments.shift();\n      }\n      return '';\n    }\n  }]);\n  return RouterSegments;\n}();\nvar readProp = function readProp(el, prop) {\n  if (prop in el) {\n    return el[prop];\n  }\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n  return null;\n};\n/**\n * Extracts the redirects (that is <ion-route-redirect> elements inside the root).\n *\n * The redirects are returned as a list of RouteRedirect.\n */\nvar readRedirects = function readRedirects(root) {\n  return Array.from(root.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE-REDIRECT';\n  }).map(function (el) {\n    var to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')).segments,\n      to: to == null ? undefined : parsePath(to)\n    };\n  });\n};\n/**\n * Extracts all the routes (that is <ion-route> elements inside the root).\n *\n * The routes are returned as a list of chains - the flattened tree.\n */\nvar readRoutes = function readRoutes(root) {\n  return flattenRouterTree(readRouteNodes(root));\n};\n/**\n * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.\n *\n * Note: routes without a component are ignored together with their children.\n */\nvar readRouteNodes = function readRouteNodes(node) {\n  return Array.from(node.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE' && el.component;\n  }).map(function (el) {\n    var component = readProp(el, 'component');\n    return {\n      segments: parsePath(readProp(el, 'url')).segments,\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      beforeLeave: el.beforeLeave,\n      beforeEnter: el.beforeEnter,\n      children: readRouteNodes(el)\n    };\n  });\n};\n/**\n * Flattens a RouterTree in a list of chains.\n *\n * Each chain represents a path from the root node to a terminal node.\n */\nvar flattenRouterTree = function flattenRouterTree(nodes) {\n  var chains = [];\n  var _iterator10 = _createForOfIteratorHelper(nodes),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var node = _step10.value;\n      flattenNode([], chains, node);\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return chains;\n};\n/** Flattens a route node recursively and push each branch to the chains list. */\nvar flattenNode = function flattenNode(chain, chains, node) {\n  chain = [].concat(_toConsumableArray(chain), [{\n    id: node.id,\n    segments: node.segments,\n    params: node.params,\n    beforeLeave: node.beforeLeave,\n    beforeEnter: node.beforeEnter\n  }]);\n  if (node.children.length === 0) {\n    chains.push(chain);\n    return;\n  }\n  var _iterator11 = _createForOfIteratorHelper(node.children),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var child = _step11.value;\n      flattenNode(chain, chains, child);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n};\nvar Router = /*@__PURE__*/proxyCustomElement( /*#__PURE__*/function (_HTMLElement) {\n  _inherits(_class, _HTMLElement);\n  var _super = _createSuper(_class);\n  function _class() {\n    var _this;\n    _classCallCheck(this, _class);\n    _this = _super.call(this);\n    _this.__registerHost();\n    _this.ionRouteWillChange = createEvent(_assertThisInitialized(_this), \"ionRouteWillChange\", 7);\n    _this.ionRouteDidChange = createEvent(_assertThisInitialized(_this), \"ionRouteDidChange\", 7);\n    _this.previousPath = null;\n    _this.busy = false;\n    _this.state = 0;\n    _this.lastState = 0;\n    /**\n     * The root path to use when matching URLs. By default, this is set to \"/\", but you can specify\n     * an alternate prefix for all URL paths.\n     */\n    _this.root = '/';\n    /**\n     * The router can work in two \"modes\":\n     * - With hash: `/index.html#/path/to/page`\n     * - Without hash: `/path/to/page`\n     *\n     * Using one or another might depend in the requirements of your app and/or where it's deployed.\n     *\n     * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n     * requires additional server-side configuration in order to properly work.\n     *\n     * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.\n     *\n     * By default, this property is `true`, change to `false` to allow hash-less URLs.\n     */\n    _this.useHash = true;\n    return _this;\n  }\n  _createClass(_class, [{\n    key: \"componentWillLoad\",\n    value: function () {\n      var _componentWillLoad = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var canProceed, redirect, path;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return waitUntilNavNode();\n            case 2:\n              _context3.next = 4;\n              return this.runGuards(this.getSegments());\n            case 4:\n              canProceed = _context3.sent;\n              if (!(canProceed !== true)) {\n                _context3.next = 14;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context3.next = 12;\n                break;\n              }\n              redirect = canProceed.redirect;\n              path = parsePath(redirect);\n              this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);\n              _context3.next = 12;\n              return this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);\n            case 12:\n              _context3.next = 16;\n              break;\n            case 14:\n              _context3.next = 16;\n              return this.onRoutesChanged();\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function componentWillLoad() {\n        return _componentWillLoad.apply(this, arguments);\n      }\n      return componentWillLoad;\n    }()\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n      window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n    }\n  }, {\n    key: \"onPopState\",\n    value: function () {\n      var _onPopState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var direction, segments, canProceed;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              direction = this.historyDirection();\n              segments = this.getSegments();\n              _context4.next = 4;\n              return this.runGuards(segments);\n            case 4:\n              canProceed = _context4.sent;\n              if (!(canProceed !== true)) {\n                _context4.next = 11;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context4.next = 10;\n                break;\n              }\n              segments = parsePath(canProceed.redirect).segments;\n              _context4.next = 11;\n              break;\n            case 10:\n              return _context4.abrupt(\"return\", false);\n            case 11:\n              return _context4.abrupt(\"return\", this.writeNavStateRoot(segments, direction));\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function onPopState() {\n        return _onPopState.apply(this, arguments);\n      }\n      return onPopState;\n    }()\n  }, {\n    key: \"onBackButton\",\n    value: function onBackButton(ev) {\n      var _this2 = this;\n      ev.detail.register(0, function (processNextHandler) {\n        _this2.back();\n        processNextHandler();\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"canTransition\",\n    value: function () {\n      var _canTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var canProceed;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.runGuards();\n            case 2:\n              canProceed = _context5.sent;\n              if (!(canProceed !== true)) {\n                _context5.next = 9;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context5.next = 8;\n                break;\n              }\n              return _context5.abrupt(\"return\", canProceed.redirect);\n            case 8:\n              return _context5.abrupt(\"return\", false);\n            case 9:\n              return _context5.abrupt(\"return\", true);\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function canTransition() {\n        return _canTransition.apply(this, arguments);\n      }\n      return canTransition;\n    }()\n    /**\n     * Navigate to the specified path.\n     *\n     * @param path The path to navigate to.\n     * @param direction The direction of the animation. Defaults to `\"forward\"`.\n     */\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(path) {\n        var direction,\n          animation,\n          _a,\n          currentPath,\n          url,\n          parsedPath,\n          canProceed,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              direction = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'forward';\n              animation = _args6.length > 2 ? _args6[2] : undefined;\n              if (path.startsWith('.')) {\n                currentPath = (_a = this.previousPath) !== null && _a !== void 0 ? _a : '/'; // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.\n                url = new URL(path, \"https://host/\".concat(currentPath));\n                path = url.pathname + url.search;\n              }\n              parsedPath = parsePath(path);\n              _context6.next = 6;\n              return this.runGuards(parsedPath.segments);\n            case 6:\n              canProceed = _context6.sent;\n              if (!(canProceed !== true)) {\n                _context6.next = 13;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context6.next = 12;\n                break;\n              }\n              parsedPath = parsePath(canProceed.redirect);\n              _context6.next = 13;\n              break;\n            case 12:\n              return _context6.abrupt(\"return\", false);\n            case 13:\n              this.setSegments(parsedPath.segments, direction, parsedPath.queryString);\n              return _context6.abrupt(\"return\", this.writeNavStateRoot(parsedPath.segments, direction, animation));\n            case 15:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function push(_x6) {\n        return _push.apply(this, arguments);\n      }\n      return push;\n    }() /** Go back to previous page in the window.history. */\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n      return Promise.resolve(this.waitPromise);\n    }\n    /** @internal */\n  }, {\n    key: \"printDebug\",\n    value: function () {\n      var _printDebug = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              printRoutes(readRoutes(this.el));\n              printRedirects(readRedirects(this.el));\n            case 2:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function printDebug() {\n        return _printDebug.apply(this, arguments);\n      }\n      return printDebug;\n    }() /** @internal */\n  }, {\n    key: \"navChanged\",\n    value: function () {\n      var _navChanged = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(direction) {\n        var _yield$readNavState, ids, outlet, routes, chain, segments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!this.busy) {\n                _context8.next = 3;\n                break;\n              }\n              console.warn('[ion-router] router is busy, navChanged was cancelled');\n              return _context8.abrupt(\"return\", false);\n            case 3:\n              _context8.next = 5;\n              return readNavState(window.document.body);\n            case 5:\n              _yield$readNavState = _context8.sent;\n              ids = _yield$readNavState.ids;\n              outlet = _yield$readNavState.outlet;\n              routes = readRoutes(this.el);\n              chain = findChainForIDs(ids, routes);\n              if (chain) {\n                _context8.next = 13;\n                break;\n              }\n              console.warn('[ion-router] no matching URL for ', ids.map(function (i) {\n                return i.id;\n              }));\n              return _context8.abrupt(\"return\", false);\n            case 13:\n              segments = chainToSegments(chain);\n              if (segments) {\n                _context8.next = 17;\n                break;\n              }\n              console.warn('[ion-router] router could not match path because some required param is missing');\n              return _context8.abrupt(\"return\", false);\n            case 17:\n              this.setSegments(segments, direction);\n              _context8.next = 20;\n              return this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);\n            case 20:\n              return _context8.abrupt(\"return\", true);\n            case 21:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function navChanged(_x7) {\n        return _navChanged.apply(this, arguments);\n      }\n      return navChanged;\n    }() /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */\n  }, {\n    key: \"onRedirectChanged\",\n    value: function onRedirectChanged() {\n      var segments = this.getSegments();\n      if (segments && findRouteRedirect(segments, readRedirects(this.el))) {\n        this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);\n      }\n    }\n    /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */\n  }, {\n    key: \"onRoutesChanged\",\n    value: function onRoutesChanged() {\n      return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);\n    }\n  }, {\n    key: \"historyDirection\",\n    value: function historyDirection() {\n      var _a;\n      var win = window;\n      if (win.history.state === null) {\n        this.state++;\n        win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);\n      }\n      var state = win.history.state;\n      var lastState = this.lastState;\n      this.lastState = state;\n      if (state > lastState || state >= lastState && lastState > 0) {\n        return ROUTER_INTENT_FORWARD;\n      }\n      if (state < lastState) {\n        return ROUTER_INTENT_BACK;\n      }\n      return ROUTER_INTENT_NONE;\n    }\n  }, {\n    key: \"writeNavStateRoot\",\n    value: function () {\n      var _writeNavStateRoot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(segments, direction, animation) {\n        var redirects, redirect, redirectFrom, _redirect$to, toSegments, queryString, routes, chain;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (segments) {\n                _context9.next = 3;\n                break;\n              }\n              console.error('[ion-router] URL is not part of the routing set');\n              return _context9.abrupt(\"return\", false);\n            case 3:\n              // lookup redirect rule\n              redirects = readRedirects(this.el);\n              redirect = findRouteRedirect(segments, redirects);\n              redirectFrom = null;\n              if (redirect) {\n                _redirect$to = redirect.to, toSegments = _redirect$to.segments, queryString = _redirect$to.queryString;\n                this.setSegments(toSegments, direction, queryString);\n                redirectFrom = redirect.from;\n                segments = toSegments;\n              }\n              // lookup route chain\n              routes = readRoutes(this.el);\n              chain = findChainForSegments(segments, routes);\n              if (chain) {\n                _context9.next = 12;\n                break;\n              }\n              console.error('[ion-router] the path does not match any route');\n              return _context9.abrupt(\"return\", false);\n            case 12:\n              return _context9.abrupt(\"return\", this.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation));\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function writeNavStateRoot(_x8, _x9, _x10) {\n        return _writeNavStateRoot.apply(this, arguments);\n      }\n      return writeNavStateRoot;\n    }()\n  }, {\n    key: \"safeWriteNavState\",\n    value: function () {\n      var _safeWriteNavState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(node, chain, direction, segments, redirectFrom) {\n        var index,\n          animation,\n          unlock,\n          changed,\n          _args10 = arguments;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              index = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : 0;\n              animation = _args10.length > 6 ? _args10[6] : undefined;\n              _context10.next = 4;\n              return this.lock();\n            case 4:\n              unlock = _context10.sent;\n              changed = false;\n              _context10.prev = 6;\n              _context10.next = 9;\n              return this.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);\n            case 9:\n              changed = _context10.sent;\n              _context10.next = 15;\n              break;\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](6);\n              console.error(_context10.t0);\n            case 15:\n              unlock();\n              return _context10.abrupt(\"return\", changed);\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[6, 12]]);\n      }));\n      function safeWriteNavState(_x11, _x12, _x13, _x14, _x15) {\n        return _safeWriteNavState.apply(this, arguments);\n      }\n      return safeWriteNavState;\n    }()\n  }, {\n    key: \"lock\",\n    value: function () {\n      var _lock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var p, resolve;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              p = this.waitPromise;\n              this.waitPromise = new Promise(function (r) {\n                return resolve = r;\n              });\n              if (!(p !== undefined)) {\n                _context11.next = 5;\n                break;\n              }\n              _context11.next = 5;\n              return p;\n            case 5:\n              return _context11.abrupt(\"return\", resolve);\n            case 6:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function lock() {\n        return _lock.apply(this, arguments);\n      }\n      return lock;\n    }()\n    /**\n     * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.\n     *\n     * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.\n     * Otherwise the beforeEnterHook hook of the target route is executed.\n     */\n  }, {\n    key: \"runGuards\",\n    value: function () {\n      var _runGuards = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var to,\n          from,\n          routes,\n          fromChain,\n          beforeLeaveHook,\n          canLeave,\n          toChain,\n          beforeEnterHook,\n          _args12 = arguments;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              to = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : this.getSegments();\n              from = _args12.length > 1 ? _args12[1] : undefined;\n              if (from === undefined) {\n                from = parsePath(this.previousPath).segments;\n              }\n              if (!(!to || !from)) {\n                _context12.next = 5;\n                break;\n              }\n              return _context12.abrupt(\"return\", true);\n            case 5:\n              routes = readRoutes(this.el);\n              fromChain = findChainForSegments(from, routes);\n              beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\n              if (!beforeLeaveHook) {\n                _context12.next = 14;\n                break;\n              }\n              _context12.next = 11;\n              return beforeLeaveHook();\n            case 11:\n              _context12.t0 = _context12.sent;\n              _context12.next = 15;\n              break;\n            case 14:\n              _context12.t0 = true;\n            case 15:\n              canLeave = _context12.t0;\n              if (!(canLeave === false || typeof canLeave === 'object')) {\n                _context12.next = 18;\n                break;\n              }\n              return _context12.abrupt(\"return\", canLeave);\n            case 18:\n              toChain = findChainForSegments(to, routes);\n              beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\n              return _context12.abrupt(\"return\", beforeEnterHook ? beforeEnterHook() : true);\n            case 21:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function runGuards() {\n        return _runGuards.apply(this, arguments);\n      }\n      return runGuards;\n    }()\n  }, {\n    key: \"writeNavState\",\n    value: function () {\n      var _writeNavState2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(node, chain, direction, segments, redirectFrom) {\n        var index,\n          animation,\n          routeEvent,\n          changed,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              index = _args13.length > 5 && _args13[5] !== undefined ? _args13[5] : 0;\n              animation = _args13.length > 6 ? _args13[6] : undefined;\n              if (!this.busy) {\n                _context13.next = 5;\n                break;\n              }\n              console.warn('[ion-router] router is busy, transition was cancelled');\n              return _context13.abrupt(\"return\", false);\n            case 5:\n              this.busy = true;\n              // generate route event and emit will change\n              routeEvent = this.routeChangeEvent(segments, redirectFrom);\n              if (routeEvent) {\n                this.ionRouteWillChange.emit(routeEvent);\n              }\n              _context13.next = 10;\n              return _writeNavState(node, chain, direction, index, false, animation);\n            case 10:\n              changed = _context13.sent;\n              this.busy = false;\n              // emit did change\n              if (routeEvent) {\n                this.ionRouteDidChange.emit(routeEvent);\n              }\n              return _context13.abrupt(\"return\", changed);\n            case 14:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function writeNavState(_x16, _x17, _x18, _x19, _x20) {\n        return _writeNavState2.apply(this, arguments);\n      }\n      return writeNavState;\n    }()\n  }, {\n    key: \"setSegments\",\n    value: function setSegments(segments, direction, queryString) {\n      this.state++;\n      writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);\n    }\n  }, {\n    key: \"getSegments\",\n    value: function getSegments() {\n      return readSegments(window.location, this.root, this.useHash);\n    }\n  }, {\n    key: \"routeChangeEvent\",\n    value: function routeChangeEvent(toSegments, redirectFromSegments) {\n      var from = this.previousPath;\n      var to = generatePath(toSegments);\n      this.previousPath = to;\n      if (to === from) {\n        return null;\n      }\n      var redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;\n      return {\n        from: from,\n        redirectedFrom: redirectedFrom,\n        to: to\n      };\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }]);\n  return _class;\n}(HTMLElement), [0, \"ion-router\", {\n  \"root\": [1],\n  \"useHash\": [4, \"use-hash\"],\n  \"canTransition\": [64],\n  \"push\": [64],\n  \"back\": [64],\n  \"printDebug\": [64],\n  \"navChanged\": [64]\n}, [[8, \"popstate\", \"onPopState\"], [4, \"ionBackButton\", \"onBackButton\"]]]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  var components = [\"ion-router\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-router\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, Router);\n        }\n        break;\n    }\n  });\n}\nvar IonRouter = Router;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonRouter, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","c","componentOnReady","o","debounce","ROUTER_INTENT_NONE","ROUTER_INTENT_FORWARD","ROUTER_INTENT_BACK","generatePath","segments","path","filter","s","length","join","generateUrl","useHash","queryString","url","undefined","writeSegments","history","root","direction","state","parsePath","pushState","replaceState","chainToSegments","chain","route","segment","param","params","slice","push","removePrefix","prefix","i","readSegments","loc","pathname","hash","qsStart","indexOf","substring","split","map","trim","printRoutes","routes","console","group","forEach","r","ids","id","debug","groupEnd","printRedirects","redirects","redirect","to","from","writeNavState","index","changed","animation","outlet","searchNavNode","Promise","resolve","setRouteId","result","element","markVisible","error","readNavState","node","getRouteId","waitUntilNavNode","document","body","window","addEventListener","once","OUTLET_SELECTOR","matches","querySelector","matchesRedirect","expected","findRouteRedirect","find","matchesIDs","len","Math","min","score","routeId","routeChain","toLowerCase","routeIdParams","Object","keys","pathWithParams","key","j","matchesSegments","inputSegments","RouterSegments","matchesDefault","allparams","chainSegments","data","next","mergeParams","beforeEnter","beforeLeave","a","b","assign","findChainForIDs","chains","match","maxMatches","_a","findChainForSegments","bestScore","matchedChain","computePriority","level","pow","shift","readProp","el","prop","hasAttribute","getAttribute","readRedirects","Array","children","tagName","readRoutes","flattenRouterTree","readRouteNodes","component","componentProps","nodes","flattenNode","child","Router","__registerHost","ionRouteWillChange","ionRouteDidChange","previousPath","busy","lastState","runGuards","getSegments","canProceed","setSegments","writeNavStateRoot","onRoutesChanged","onRedirectChanged","bind","historyDirection","ev","detail","register","processNextHandler","back","startsWith","currentPath","URL","search","parsedPath","waitPromise","warn","safeWriteNavState","win","title","location","href","redirectFrom","toSegments","lock","unlock","p","fromChain","beforeLeaveHook","canLeave","toChain","beforeEnterHook","routeEvent","routeChangeEvent","emit","redirectFromSegments","redirectedFrom","defineCustomElement$1","customElements","components","get","define","IonRouter","defineCustomElement"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@ionic/core/components/ion-router.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent } from '@stencil/core/internal/client';\nimport { c as componentOnReady, o as debounce } from './helpers.js';\n\nconst ROUTER_INTENT_NONE = 'root';\nconst ROUTER_INTENT_FORWARD = 'forward';\nconst ROUTER_INTENT_BACK = 'back';\n\n/** Join the non empty segments with \"/\". */\nconst generatePath = (segments) => {\n  const path = segments.filter((s) => s.length > 0).join('/');\n  return '/' + path;\n};\nconst generateUrl = (segments, useHash, queryString) => {\n  let url = generatePath(segments);\n  if (useHash) {\n    url = '#' + url;\n  }\n  if (queryString !== undefined) {\n    url += '?' + queryString;\n  }\n  return url;\n};\nconst writeSegments = (history, root, useHash, segments, direction, state, queryString) => {\n  const url = generateUrl([...parsePath(root).segments, ...segments], useHash, queryString);\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  }\n  else {\n    history.replaceState(state, '', url);\n  }\n};\n/**\n * Transforms a chain to a list of segments.\n *\n * Notes:\n * - parameter segments of the form :param are replaced with their value,\n * - null is returned when a value is missing for any parameter segment.\n */\nconst chainToSegments = (chain) => {\n  const segments = [];\n  for (const route of chain) {\n    for (const segment of route.segments) {\n      if (segment[0] === ':') {\n        const param = route.params && route.params[segment.slice(1)];\n        if (!param) {\n          return null;\n        }\n        segments.push(param);\n      }\n      else if (segment !== '') {\n        segments.push(segment);\n      }\n    }\n  }\n  return segments;\n};\n/**\n * Removes the prefix segments from the path segments.\n *\n * Return:\n * - null when the path segments do not start with the passed prefix,\n * - the path segments after the prefix otherwise.\n */\nconst removePrefix = (prefix, segments) => {\n  if (prefix.length > segments.length) {\n    return null;\n  }\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return segments;\n  }\n  for (let i = 0; i < prefix.length; i++) {\n    if (prefix[i] !== segments[i]) {\n      return null;\n    }\n  }\n  if (segments.length === prefix.length) {\n    return [''];\n  }\n  return segments.slice(prefix.length);\n};\nconst readSegments = (loc, root, useHash) => {\n  const prefix = parsePath(root).segments;\n  const pathname = useHash ? loc.hash.slice(1) : loc.pathname;\n  const segments = parsePath(pathname).segments;\n  return removePrefix(prefix, segments);\n};\n/**\n * Parses the path to:\n * - segments an array of '/' separated parts,\n * - queryString (undefined when no query string).\n */\nconst parsePath = (path) => {\n  let segments = [''];\n  let queryString;\n  if (path != null) {\n    const qsStart = path.indexOf('?');\n    if (qsStart > -1) {\n      queryString = path.substring(qsStart + 1);\n      path = path.substring(0, qsStart);\n    }\n    segments = path\n      .split('/')\n      .map((s) => s.trim())\n      .filter((s) => s.length > 0);\n    if (segments.length === 0) {\n      segments = [''];\n    }\n  }\n  return { segments, queryString };\n};\n\nconst printRoutes = (routes) => {\n  console.group(`[ion-core] ROUTES[${routes.length}]`);\n  for (const chain of routes) {\n    const segments = [];\n    chain.forEach((r) => segments.push(...r.segments));\n    const ids = chain.map((r) => r.id);\n    console.debug(`%c ${generatePath(segments)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\n  }\n  console.groupEnd();\n};\nconst printRedirects = (redirects) => {\n  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\n  for (const redirect of redirects) {\n    if (redirect.to) {\n      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to.segments)}`, 'font-weight: bold');\n    }\n  }\n  console.groupEnd();\n};\n\n/**\n * Activates the passed route chain.\n *\n * There must be exactly one outlet per route entry in the chain.\n *\n * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.\n * setRouteId will create or select the view in the outlet.\n */\nconst writeNavState = async (root, chain, direction, index, changed = false, animation) => {\n  try {\n    // find next navigation outlet in the DOM\n    const outlet = searchNavNode(root);\n    // make sure we can continue interacting the DOM, otherwise abort\n    if (index >= chain.length || !outlet) {\n      return changed;\n    }\n    await new Promise((resolve) => componentOnReady(outlet, resolve));\n    const route = chain[index];\n    const result = await outlet.setRouteId(route.id, route.params, direction, animation);\n    // if the outlet changed the page, reset navigation to neutral (no direction)\n    // this means nested outlets will not animate\n    if (result.changed) {\n      direction = ROUTER_INTENT_NONE;\n      changed = true;\n    }\n    // recursively set nested outlets\n    changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);\n    // once all nested outlets are visible let's make the parent visible too,\n    // using markVisible prevents flickering\n    if (result.markVisible) {\n      await result.markVisible();\n    }\n    return changed;\n  }\n  catch (e) {\n    console.error(e);\n    return false;\n  }\n};\n/**\n * Recursively walks the outlet in the DOM.\n *\n * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.\n */\nconst readNavState = async (root) => {\n  const ids = [];\n  let outlet;\n  let node = root;\n  // eslint-disable-next-line no-cond-assign\n  while ((outlet = searchNavNode(node))) {\n    const id = await outlet.getRouteId();\n    if (id) {\n      node = id.element;\n      id.element = undefined;\n      ids.push(id);\n    }\n    else {\n      break;\n    }\n  }\n  return { ids, outlet };\n};\nconst waitUntilNavNode = () => {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n  return new Promise((resolve) => {\n    window.addEventListener('ionNavWillLoad', () => resolve(), { once: true });\n  });\n};\n/** Selector for all the outlets supported by the router. */\nconst OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nconst searchNavNode = (root) => {\n  if (!root) {\n    return undefined;\n  }\n  if (root.matches(OUTLET_SELECTOR)) {\n    return root;\n  }\n  const outlet = root.querySelector(OUTLET_SELECTOR);\n  return outlet !== null && outlet !== void 0 ? outlet : undefined;\n};\n\n/**\n * Returns whether the given redirect matches the given path segments.\n *\n * A redirect matches when the segments of the path and redirect.from are equal.\n * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.\n * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].\n */\nconst matchesRedirect = (segments, redirect) => {\n  const { from, to } = redirect;\n  if (to === undefined) {\n    return false;\n  }\n  if (from.length > segments.length) {\n    return false;\n  }\n  for (let i = 0; i < from.length; i++) {\n    const expected = from[i];\n    if (expected === '*') {\n      return true;\n    }\n    if (expected !== segments[i]) {\n      return false;\n    }\n  }\n  return from.length === segments.length;\n};\n/** Returns the first redirect matching the path segments or undefined when no match found. */\nconst findRouteRedirect = (segments, redirects) => {\n  return redirects.find((redirect) => matchesRedirect(segments, redirect));\n};\nconst matchesIDs = (ids, chain) => {\n  const len = Math.min(ids.length, chain.length);\n  let score = 0;\n  for (let i = 0; i < len; i++) {\n    const routeId = ids[i];\n    const routeChain = chain[i];\n    // Skip results where the route id does not match the chain at the same index\n    if (routeId.id.toLowerCase() !== routeChain.id) {\n      break;\n    }\n    if (routeId.params) {\n      const routeIdParams = Object.keys(routeId.params);\n      // Only compare routes with the chain that have the same number of parameters.\n      if (routeIdParams.length === routeChain.segments.length) {\n        // Maps the route's params into a path based on the path variable names,\n        // to compare against the route chain format.\n        //\n        // Before:\n        // ```ts\n        // {\n        //  params: {\n        //    s1: 'a',\n        //    s2: 'b'\n        //  }\n        // }\n        // ```\n        //\n        // After:\n        // ```ts\n        // [':s1',':s2']\n        // ```\n        //\n        const pathWithParams = routeIdParams.map((key) => `:${key}`);\n        for (let j = 0; j < pathWithParams.length; j++) {\n          // Skip results where the path variable is not a match\n          if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {\n            break;\n          }\n          // Weight path matches for the same index higher.\n          score++;\n        }\n      }\n    }\n    // Weight id matches\n    score++;\n  }\n  return score;\n};\n/**\n * Matches the segments against the chain.\n *\n * Returns:\n * - null when there is no match,\n * - a chain with the params properties updated with the parameter segments on match.\n */\nconst matchesSegments = (segments, chain) => {\n  const inputSegments = new RouterSegments(segments);\n  let matchesDefault = false;\n  let allparams;\n  for (let i = 0; i < chain.length; i++) {\n    const chainSegments = chain[i].segments;\n    if (chainSegments[0] === '') {\n      matchesDefault = true;\n    }\n    else {\n      for (const segment of chainSegments) {\n        const data = inputSegments.next();\n        // data param\n        if (segment[0] === ':') {\n          if (data === '') {\n            return null;\n          }\n          allparams = allparams || [];\n          const params = allparams[i] || (allparams[i] = {});\n          params[segment.slice(1)] = data;\n        }\n        else if (data !== segment) {\n          return null;\n        }\n      }\n      matchesDefault = false;\n    }\n  }\n  const matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;\n  if (!matches) {\n    return null;\n  }\n  if (allparams) {\n    return chain.map((route, i) => ({\n      id: route.id,\n      segments: route.segments,\n      params: mergeParams(route.params, allparams[i]),\n      beforeEnter: route.beforeEnter,\n      beforeLeave: route.beforeLeave,\n    }));\n  }\n  return chain;\n};\n/**\n * Merges the route parameter objects.\n * Returns undefined when both parameters are undefined.\n */\nconst mergeParams = (a, b) => {\n  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;\n};\n/**\n * Finds the best match for the ids in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the RouteIDs.\n * That is they contain both the componentProps of the <ion-route> and the parameter segment.\n */\nconst findChainForIDs = (ids, chains) => {\n  let match = null;\n  let maxMatches = 0;\n  for (const chain of chains) {\n    const score = matchesIDs(ids, chain);\n    if (score > maxMatches) {\n      match = chain;\n      maxMatches = score;\n    }\n  }\n  if (match) {\n    return match.map((route, i) => {\n      var _a;\n      return ({\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params),\n      });\n    });\n  }\n  return null;\n};\n/**\n * Finds the best match for the segments in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the segments.\n * That is they contain both the componentProps of the <ion-route> and the parameter segments.\n */\nconst findChainForSegments = (segments, chains) => {\n  let match = null;\n  let bestScore = 0;\n  for (const chain of chains) {\n    const matchedChain = matchesSegments(segments, chain);\n    if (matchedChain !== null) {\n      const score = computePriority(matchedChain);\n      if (score > bestScore) {\n        bestScore = score;\n        match = matchedChain;\n      }\n    }\n  }\n  return match;\n};\n/**\n * Computes the priority of a chain.\n *\n * Parameter segments are given a lower priority over fixed segments.\n *\n * Considering the following 2 chains matching the path /path/to/page:\n * - /path/to/:where\n * - /path/to/page\n *\n * The second one will be given a higher priority because \"page\" is a fixed segment (vs \":where\", a parameter segment).\n */\nconst computePriority = (chain) => {\n  let score = 1;\n  let level = 1;\n  for (const route of chain) {\n    for (const segment of route.segments) {\n      if (segment[0] === ':') {\n        score += Math.pow(1, level);\n      }\n      else if (segment !== '') {\n        score += Math.pow(2, level);\n      }\n      level++;\n    }\n  }\n  return score;\n};\nclass RouterSegments {\n  constructor(segments) {\n    this.segments = segments.slice();\n  }\n  next() {\n    if (this.segments.length > 0) {\n      return this.segments.shift();\n    }\n    return '';\n  }\n}\n\nconst readProp = (el, prop) => {\n  if (prop in el) {\n    return el[prop];\n  }\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n  return null;\n};\n/**\n * Extracts the redirects (that is <ion-route-redirect> elements inside the root).\n *\n * The redirects are returned as a list of RouteRedirect.\n */\nconst readRedirects = (root) => {\n  return Array.from(root.children)\n    .filter((el) => el.tagName === 'ION-ROUTE-REDIRECT')\n    .map((el) => {\n    const to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')).segments,\n      to: to == null ? undefined : parsePath(to),\n    };\n  });\n};\n/**\n * Extracts all the routes (that is <ion-route> elements inside the root).\n *\n * The routes are returned as a list of chains - the flattened tree.\n */\nconst readRoutes = (root) => {\n  return flattenRouterTree(readRouteNodes(root));\n};\n/**\n * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.\n *\n * Note: routes without a component are ignored together with their children.\n */\nconst readRouteNodes = (node) => {\n  return Array.from(node.children)\n    .filter((el) => el.tagName === 'ION-ROUTE' && el.component)\n    .map((el) => {\n    const component = readProp(el, 'component');\n    return {\n      segments: parsePath(readProp(el, 'url')).segments,\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      beforeLeave: el.beforeLeave,\n      beforeEnter: el.beforeEnter,\n      children: readRouteNodes(el),\n    };\n  });\n};\n/**\n * Flattens a RouterTree in a list of chains.\n *\n * Each chain represents a path from the root node to a terminal node.\n */\nconst flattenRouterTree = (nodes) => {\n  const chains = [];\n  for (const node of nodes) {\n    flattenNode([], chains, node);\n  }\n  return chains;\n};\n/** Flattens a route node recursively and push each branch to the chains list. */\nconst flattenNode = (chain, chains, node) => {\n  chain = [\n    ...chain,\n    {\n      id: node.id,\n      segments: node.segments,\n      params: node.params,\n      beforeLeave: node.beforeLeave,\n      beforeEnter: node.beforeEnter,\n    },\n  ];\n  if (node.children.length === 0) {\n    chains.push(chain);\n    return;\n  }\n  for (const child of node.children) {\n    flattenNode(chain, chains, child);\n  }\n};\n\nconst Router = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\n    this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\n    this.previousPath = null;\n    this.busy = false;\n    this.state = 0;\n    this.lastState = 0;\n    /**\n     * The root path to use when matching URLs. By default, this is set to \"/\", but you can specify\n     * an alternate prefix for all URL paths.\n     */\n    this.root = '/';\n    /**\n     * The router can work in two \"modes\":\n     * - With hash: `/index.html#/path/to/page`\n     * - Without hash: `/path/to/page`\n     *\n     * Using one or another might depend in the requirements of your app and/or where it's deployed.\n     *\n     * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n     * requires additional server-side configuration in order to properly work.\n     *\n     * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.\n     *\n     * By default, this property is `true`, change to `false` to allow hash-less URLs.\n     */\n    this.useHash = true;\n  }\n  async componentWillLoad() {\n    await waitUntilNavNode();\n    const canProceed = await this.runGuards(this.getSegments());\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        const { redirect } = canProceed;\n        const path = parsePath(redirect);\n        this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);\n        await this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);\n      }\n    }\n    else {\n      await this.onRoutesChanged();\n    }\n  }\n  componentDidLoad() {\n    window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n    window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n  }\n  async onPopState() {\n    const direction = this.historyDirection();\n    let segments = this.getSegments();\n    const canProceed = await this.runGuards(segments);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        segments = parsePath(canProceed.redirect).segments;\n      }\n      else {\n        return false;\n      }\n    }\n    return this.writeNavStateRoot(segments, direction);\n  }\n  onBackButton(ev) {\n    ev.detail.register(0, (processNextHandler) => {\n      this.back();\n      processNextHandler();\n    });\n  }\n  /** @internal */\n  async canTransition() {\n    const canProceed = await this.runGuards();\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        return canProceed.redirect;\n      }\n      else {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Navigate to the specified path.\n   *\n   * @param path The path to navigate to.\n   * @param direction The direction of the animation. Defaults to `\"forward\"`.\n   */\n  async push(path, direction = 'forward', animation) {\n    var _a;\n    if (path.startsWith('.')) {\n      const currentPath = (_a = this.previousPath) !== null && _a !== void 0 ? _a : '/';\n      // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.\n      const url = new URL(path, `https://host/${currentPath}`);\n      path = url.pathname + url.search;\n    }\n    let parsedPath = parsePath(path);\n    const canProceed = await this.runGuards(parsedPath.segments);\n    if (canProceed !== true) {\n      if (typeof canProceed === 'object') {\n        parsedPath = parsePath(canProceed.redirect);\n      }\n      else {\n        return false;\n      }\n    }\n    this.setSegments(parsedPath.segments, direction, parsedPath.queryString);\n    return this.writeNavStateRoot(parsedPath.segments, direction, animation);\n  }\n  /** Go back to previous page in the window.history. */\n  back() {\n    window.history.back();\n    return Promise.resolve(this.waitPromise);\n  }\n  /** @internal */\n  async printDebug() {\n    printRoutes(readRoutes(this.el));\n    printRedirects(readRedirects(this.el));\n  }\n  /** @internal */\n  async navChanged(direction) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, navChanged was cancelled');\n      return false;\n    }\n    const { ids, outlet } = await readNavState(window.document.body);\n    const routes = readRoutes(this.el);\n    const chain = findChainForIDs(ids, routes);\n    if (!chain) {\n      console.warn('[ion-router] no matching URL for ', ids.map((i) => i.id));\n      return false;\n    }\n    const segments = chainToSegments(chain);\n    if (!segments) {\n      console.warn('[ion-router] router could not match path because some required param is missing');\n      return false;\n    }\n    this.setSegments(segments, direction);\n    await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);\n    return true;\n  }\n  /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */\n  onRedirectChanged() {\n    const segments = this.getSegments();\n    if (segments && findRouteRedirect(segments, readRedirects(this.el))) {\n      this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);\n    }\n  }\n  /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */\n  onRoutesChanged() {\n    return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);\n  }\n  historyDirection() {\n    var _a;\n    const win = window;\n    if (win.history.state === null) {\n      this.state++;\n      win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);\n    }\n    const state = win.history.state;\n    const lastState = this.lastState;\n    this.lastState = state;\n    if (state > lastState || (state >= lastState && lastState > 0)) {\n      return ROUTER_INTENT_FORWARD;\n    }\n    if (state < lastState) {\n      return ROUTER_INTENT_BACK;\n    }\n    return ROUTER_INTENT_NONE;\n  }\n  async writeNavStateRoot(segments, direction, animation) {\n    if (!segments) {\n      console.error('[ion-router] URL is not part of the routing set');\n      return false;\n    }\n    // lookup redirect rule\n    const redirects = readRedirects(this.el);\n    const redirect = findRouteRedirect(segments, redirects);\n    let redirectFrom = null;\n    if (redirect) {\n      const { segments: toSegments, queryString } = redirect.to;\n      this.setSegments(toSegments, direction, queryString);\n      redirectFrom = redirect.from;\n      segments = toSegments;\n    }\n    // lookup route chain\n    const routes = readRoutes(this.el);\n    const chain = findChainForSegments(segments, routes);\n    if (!chain) {\n      console.error('[ion-router] the path does not match any route');\n      return false;\n    }\n    // write DOM give\n    return this.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation);\n  }\n  async safeWriteNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise((r) => (resolve = r));\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  /**\n   * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.\n   *\n   * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.\n   * Otherwise the beforeEnterHook hook of the target route is executed.\n   */\n  async runGuards(to = this.getSegments(), from) {\n    if (from === undefined) {\n      from = parsePath(this.previousPath).segments;\n    }\n    if (!to || !from) {\n      return true;\n    }\n    const routes = readRoutes(this.el);\n    const fromChain = findChainForSegments(from, routes);\n    const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\n    const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;\n    if (canLeave === false || typeof canLeave === 'object') {\n      return canLeave;\n    }\n    const toChain = findChainForSegments(to, routes);\n    const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\n    return beforeEnterHook ? beforeEnterHook() : true;\n  }\n  async writeNavState(node, chain, direction, segments, redirectFrom, index = 0, animation) {\n    if (this.busy) {\n      console.warn('[ion-router] router is busy, transition was cancelled');\n      return false;\n    }\n    this.busy = true;\n    // generate route event and emit will change\n    const routeEvent = this.routeChangeEvent(segments, redirectFrom);\n    if (routeEvent) {\n      this.ionRouteWillChange.emit(routeEvent);\n    }\n    const changed = await writeNavState(node, chain, direction, index, false, animation);\n    this.busy = false;\n    // emit did change\n    if (routeEvent) {\n      this.ionRouteDidChange.emit(routeEvent);\n    }\n    return changed;\n  }\n  setSegments(segments, direction, queryString) {\n    this.state++;\n    writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);\n  }\n  getSegments() {\n    return readSegments(window.location, this.root, this.useHash);\n  }\n  routeChangeEvent(toSegments, redirectFromSegments) {\n    const from = this.previousPath;\n    const to = generatePath(toSegments);\n    this.previousPath = to;\n    if (to === from) {\n      return null;\n    }\n    const redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;\n    return {\n      from,\n      redirectedFrom,\n      to,\n    };\n  }\n  get el() { return this; }\n}, [0, \"ion-router\", {\n    \"root\": [1],\n    \"useHash\": [4, \"use-hash\"],\n    \"canTransition\": [64],\n    \"push\": [64],\n    \"back\": [64],\n    \"printDebug\": [64],\n    \"navChanged\": [64]\n  }, [[8, \"popstate\", \"onPopState\"], [4, \"ionBackButton\", \"onBackButton\"]]]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Router);\n      }\n      break;\n  } });\n}\n\nconst IonRouter = Router;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonRouter, defineCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}