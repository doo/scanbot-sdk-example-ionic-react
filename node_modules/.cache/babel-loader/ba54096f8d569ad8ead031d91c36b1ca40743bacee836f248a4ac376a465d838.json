{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nvar _getEffectiveRequest = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var request, mode, _ref$plugins, plugins, cacheKeyWillBeUsedPlugins, effectiveRequest, _iterator, _step, plugin;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          request = _ref.request, mode = _ref.mode, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n          cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n          effectiveRequest = request;\n          _iterator = _createForOfIteratorHelper(cacheKeyWillBeUsedPlugins);\n          _context.prev = 4;\n          _iterator.s();\n        case 6:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 15;\n            break;\n          }\n          plugin = _step.value;\n          _context.next = 10;\n          return plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, {\n            mode: mode,\n            request: effectiveRequest\n          });\n        case 10:\n          effectiveRequest = _context.sent;\n          if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n          }\n          if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n              moduleName: 'Plugin',\n              funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n              isReturnValueProblem: true\n            });\n          }\n        case 13:\n          _context.next = 6;\n          break;\n        case 15:\n          _context.next = 20;\n          break;\n        case 17:\n          _context.prev = 17;\n          _context.t0 = _context[\"catch\"](4);\n          _iterator.e(_context.t0);\n        case 20:\n          _context.prev = 20;\n          _iterator.f();\n          return _context.finish(20);\n        case 23:\n          return _context.abrupt(\"return\", effectiveRequest);\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[4, 17, 20, 23]]);\n  }));\n  return function _getEffectiveRequest(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nvar _isResponseSafeToCache = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n    var request, response, event, _ref3$plugins, plugins, responseToCache, pluginsUsed, _iterator2, _step2, plugin, pluginMethod;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          request = _ref3.request, response = _ref3.response, event = _ref3.event, _ref3$plugins = _ref3.plugins, plugins = _ref3$plugins === void 0 ? [] : _ref3$plugins;\n          responseToCache = response;\n          pluginsUsed = false;\n          _iterator2 = _createForOfIteratorHelper(plugins);\n          _context2.prev = 4;\n          _iterator2.s();\n        case 6:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 19;\n            break;\n          }\n          plugin = _step2.value;\n          if (!(\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin)) {\n            _context2.next = 17;\n            break;\n          }\n          pluginsUsed = true;\n          pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n          _context2.next = 13;\n          return pluginMethod.call(plugin, {\n            request: request,\n            response: responseToCache,\n            event: event\n          });\n        case 13:\n          responseToCache = _context2.sent;\n          if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n              assert.isInstance(responseToCache, Response, {\n                moduleName: 'Plugin',\n                funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                isReturnValueProblem: true\n              });\n            }\n          }\n          if (responseToCache) {\n            _context2.next = 17;\n            break;\n          }\n          return _context2.abrupt(\"break\", 19);\n        case 17:\n          _context2.next = 6;\n          break;\n        case 19:\n          _context2.next = 24;\n          break;\n        case 21:\n          _context2.prev = 21;\n          _context2.t0 = _context2[\"catch\"](4);\n          _iterator2.e(_context2.t0);\n        case 24:\n          _context2.prev = 24;\n          _iterator2.f();\n          return _context2.finish(24);\n        case 27:\n          if (!pluginsUsed) {\n            if (process.env.NODE_ENV !== 'production') {\n              if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                  if (responseToCache.status === 0) {\n                    logger.warn(\"The response for '\".concat(request.url, \"' is an opaque \") + \"response. The caching strategy that you're using will not \" + \"cache opaque responses by default.\");\n                  } else {\n                    logger.debug(\"The response for '\".concat(request.url, \"' returned \") + \"a status code of '\".concat(response.status, \"' and won't be cached as a \") + \"result.\");\n                  }\n                }\n              }\n            }\n            responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n          }\n          return _context2.abrupt(\"return\", responseToCache ? responseToCache : null);\n        case 29:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[4, 21, 24, 27]]);\n  }));\n  return function _isResponseSafeToCache(_x2) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nvar matchWrapper = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n    var cacheName, request, event, matchOptions, _ref5$plugins, plugins, cache, effectiveRequest, cachedResponse, _iterator3, _step3, plugin, pluginMethod;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          cacheName = _ref5.cacheName, request = _ref5.request, event = _ref5.event, matchOptions = _ref5.matchOptions, _ref5$plugins = _ref5.plugins, plugins = _ref5$plugins === void 0 ? [] : _ref5$plugins;\n          _context3.next = 3;\n          return self.caches.open(cacheName);\n        case 3:\n          cache = _context3.sent;\n          _context3.next = 6;\n          return _getEffectiveRequest({\n            plugins: plugins,\n            request: request,\n            mode: 'read'\n          });\n        case 6:\n          effectiveRequest = _context3.sent;\n          _context3.next = 9;\n          return cache.match(effectiveRequest, matchOptions);\n        case 9:\n          cachedResponse = _context3.sent;\n          if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n              logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n            } else {\n              logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n            }\n          }\n          _iterator3 = _createForOfIteratorHelper(plugins);\n          _context3.prev = 12;\n          _iterator3.s();\n        case 14:\n          if ((_step3 = _iterator3.n()).done) {\n            _context3.next = 24;\n            break;\n          }\n          plugin = _step3.value;\n          if (!(\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin)) {\n            _context3.next = 22;\n            break;\n          }\n          pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n          _context3.next = 20;\n          return pluginMethod.call(plugin, {\n            cacheName: cacheName,\n            event: event,\n            matchOptions: matchOptions,\n            cachedResponse: cachedResponse,\n            request: effectiveRequest\n          });\n        case 20:\n          cachedResponse = _context3.sent;\n          if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n              assert.isInstance(cachedResponse, Response, {\n                moduleName: 'Plugin',\n                funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                isReturnValueProblem: true\n              });\n            }\n          }\n        case 22:\n          _context3.next = 14;\n          break;\n        case 24:\n          _context3.next = 29;\n          break;\n        case 26:\n          _context3.prev = 26;\n          _context3.t0 = _context3[\"catch\"](12);\n          _iterator3.e(_context3.t0);\n        case 29:\n          _context3.prev = 29;\n          _iterator3.f();\n          return _context3.finish(29);\n        case 32:\n          return _context3.abrupt(\"return\", cachedResponse);\n        case 33:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[12, 26, 29, 32]]);\n  }));\n  return function matchWrapper(_x3) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nvar putWrapper = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref7) {\n    var cacheName, request, response, event, _ref7$plugins, plugins, matchOptions, effectiveRequest, responseToCache, cache, updatePlugins, oldResponse, _iterator4, _step4, plugin;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          cacheName = _ref7.cacheName, request = _ref7.request, response = _ref7.response, event = _ref7.event, _ref7$plugins = _ref7.plugins, plugins = _ref7$plugins === void 0 ? [] : _ref7$plugins, matchOptions = _ref7.matchOptions;\n          if (!(process.env.NODE_ENV !== 'production')) {\n            _context4.next = 4;\n            break;\n          }\n          if (!(request.method && request.method !== 'GET')) {\n            _context4.next = 4;\n            break;\n          }\n          throw new WorkboxError('attempt-to-cache-non-get-request', {\n            url: getFriendlyURL(request.url),\n            method: request.method\n          });\n        case 4:\n          _context4.next = 6;\n          return _getEffectiveRequest({\n            plugins: plugins,\n            request: request,\n            mode: 'write'\n          });\n        case 6:\n          effectiveRequest = _context4.sent;\n          if (response) {\n            _context4.next = 10;\n            break;\n          }\n          if (process.env.NODE_ENV !== 'production') {\n            logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n          }\n          throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url)\n          });\n        case 10:\n          _context4.next = 12;\n          return _isResponseSafeToCache({\n            event: event,\n            plugins: plugins,\n            response: response,\n            request: effectiveRequest\n          });\n        case 12:\n          responseToCache = _context4.sent;\n          if (responseToCache) {\n            _context4.next = 16;\n            break;\n          }\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' will \") + \"not be cached.\", responseToCache);\n          }\n          return _context4.abrupt(\"return\");\n        case 16:\n          _context4.next = 18;\n          return self.caches.open(cacheName);\n        case 18:\n          cache = _context4.sent;\n          updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n          if (!(updatePlugins.length > 0)) {\n            _context4.next = 26;\n            break;\n          }\n          _context4.next = 23;\n          return matchWrapper({\n            cacheName: cacheName,\n            matchOptions: matchOptions,\n            request: effectiveRequest\n          });\n        case 23:\n          _context4.t0 = _context4.sent;\n          _context4.next = 27;\n          break;\n        case 26:\n          _context4.t0 = null;\n        case 27:\n          oldResponse = _context4.t0;\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response for \") + \"\".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n          }\n          _context4.prev = 29;\n          _context4.next = 32;\n          return cache.put(effectiveRequest, responseToCache);\n        case 32:\n          _context4.next = 40;\n          break;\n        case 34:\n          _context4.prev = 34;\n          _context4.t1 = _context4[\"catch\"](29);\n          if (!(_context4.t1.name === 'QuotaExceededError')) {\n            _context4.next = 39;\n            break;\n          }\n          _context4.next = 39;\n          return executeQuotaErrorCallbacks();\n        case 39:\n          throw _context4.t1;\n        case 40:\n          _iterator4 = _createForOfIteratorHelper(updatePlugins);\n          _context4.prev = 41;\n          _iterator4.s();\n        case 43:\n          if ((_step4 = _iterator4.n()).done) {\n            _context4.next = 49;\n            break;\n          }\n          plugin = _step4.value;\n          _context4.next = 47;\n          return plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName: cacheName,\n            event: event,\n            oldResponse: oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest\n          });\n        case 47:\n          _context4.next = 43;\n          break;\n        case 49:\n          _context4.next = 54;\n          break;\n        case 51:\n          _context4.prev = 51;\n          _context4.t2 = _context4[\"catch\"](41);\n          _iterator4.e(_context4.t2);\n        case 54:\n          _context4.prev = 54;\n          _iterator4.f();\n          return _context4.finish(54);\n        case 57:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[29, 34], [41, 51, 54, 57]]);\n  }));\n  return function putWrapper(_x4) {\n    return _ref8.apply(this, arguments);\n  };\n}();\nexport var cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","self","caches","open","cache","match","cachedResponse","putWrapper","method","error","updatePlugins","length","oldResponse","put","name","newResponse","cacheWrapper"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/workbox-core/_private/cacheWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}