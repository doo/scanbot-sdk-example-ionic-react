{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar HapticEngine = {\n  getEngine: function getEngine() {\n    var _a;\n    var win = window;\n    return win.TapticEngine || ((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('Haptics')) && win.Capacitor.Plugins.Haptics;\n  },\n  available: function available() {\n    var _a;\n    var win = window;\n    var engine = this.getEngine();\n    if (!engine) {\n      return false;\n    }\n    /**\n     * Developers can manually import the\n     * Haptics plugin in their app which will cause\n     * getEngine to return the Haptics engine. However,\n     * the Haptics engine will throw an error if\n     * used in a web browser that does not support\n     * the Vibrate API. This check avoids that error\n     * if the browser does not support the Vibrate API.\n     */\n    if (((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.getPlatform()) === 'web') {\n      return typeof navigator !== 'undefined' && navigator.vibrate !== undefined;\n    }\n    return true;\n  },\n  isCordova: function isCordova() {\n    return !!window.TapticEngine;\n  },\n  isCapacitor: function isCapacitor() {\n    var win = window;\n    return !!win.Capacitor;\n  },\n  impact: function impact(options) {\n    var engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    var style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.impact({\n      style: style\n    });\n  },\n  notification: function notification(options) {\n    var engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    var style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.notification({\n      style: style\n    });\n  },\n  selection: function selection() {\n    this.impact({\n      style: 'light'\n    });\n  },\n  selectionStart: function selectionStart() {\n    var engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionStart();\n    } else {\n      engine.gestureSelectionStart();\n    }\n  },\n  selectionChanged: function selectionChanged() {\n    var engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionChanged();\n    } else {\n      engine.gestureSelectionChanged();\n    }\n  },\n  selectionEnd: function selectionEnd() {\n    var engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionEnd();\n    } else {\n      engine.gestureSelectionEnd();\n    }\n  }\n};\n/**\n * Check to see if the Haptic Plugin is available\n * @return Returns `true` or false if the plugin is available\n */\nvar hapticAvailable = function hapticAvailable() {\n  return HapticEngine.available();\n};\n/**\n * Trigger a selection changed haptic event. Good for one-time events\n * (not for gestures)\n */\nvar hapticSelection = function hapticSelection() {\n  hapticAvailable() && HapticEngine.selection();\n};\n/**\n * Tell the haptic engine that a gesture for a selection change is starting.\n */\nvar hapticSelectionStart = function hapticSelectionStart() {\n  hapticAvailable() && HapticEngine.selectionStart();\n};\n/**\n * Tell the haptic engine that a selection changed during a gesture.\n */\nvar hapticSelectionChanged = function hapticSelectionChanged() {\n  hapticAvailable() && HapticEngine.selectionChanged();\n};\n/**\n * Tell the haptic engine we are done with a gesture. This needs to be\n * called lest resources are not properly recycled.\n */\nvar hapticSelectionEnd = function hapticSelectionEnd() {\n  hapticAvailable() && HapticEngine.selectionEnd();\n};\n/**\n * Use this to indicate success/failure/warning to the user.\n * options should be of the type `{ style: 'light' }` (or `medium`/`heavy`)\n */\nvar hapticImpact = function hapticImpact(options) {\n  hapticAvailable() && HapticEngine.impact(options);\n};\nexport { hapticSelectionStart as a, hapticSelectionChanged as b, hapticSelectionEnd as c, hapticSelection as d, hapticImpact as h };","map":{"version":3,"names":["HapticEngine","getEngine","_a","win","window","TapticEngine","Capacitor","isPluginAvailable","Plugins","Haptics","available","engine","getPlatform","navigator","vibrate","undefined","isCordova","isCapacitor","impact","options","style","toUpperCase","notification","selection","selectionStart","gestureSelectionStart","selectionChanged","gestureSelectionChanged","selectionEnd","gestureSelectionEnd","hapticAvailable","hapticSelection","hapticSelectionStart","hapticSelectionChanged","hapticSelectionEnd","hapticImpact","a","b","c","d","h"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@ionic/core/components/haptic.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst HapticEngine = {\n  getEngine() {\n    var _a;\n    const win = window;\n    return win.TapticEngine || (((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('Haptics')) && win.Capacitor.Plugins.Haptics);\n  },\n  available() {\n    var _a;\n    const win = window;\n    const engine = this.getEngine();\n    if (!engine) {\n      return false;\n    }\n    /**\n     * Developers can manually import the\n     * Haptics plugin in their app which will cause\n     * getEngine to return the Haptics engine. However,\n     * the Haptics engine will throw an error if\n     * used in a web browser that does not support\n     * the Vibrate API. This check avoids that error\n     * if the browser does not support the Vibrate API.\n     */\n    if (((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.getPlatform()) === 'web') {\n      return typeof navigator !== 'undefined' && navigator.vibrate !== undefined;\n    }\n    return true;\n  },\n  isCordova() {\n    return !!window.TapticEngine;\n  },\n  isCapacitor() {\n    const win = window;\n    return !!win.Capacitor;\n  },\n  impact(options) {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.impact({ style });\n  },\n  notification(options) {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.notification({ style });\n  },\n  selection() {\n    this.impact({ style: 'light' });\n  },\n  selectionStart() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionStart();\n    }\n    else {\n      engine.gestureSelectionStart();\n    }\n  },\n  selectionChanged() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionChanged();\n    }\n    else {\n      engine.gestureSelectionChanged();\n    }\n  },\n  selectionEnd() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionEnd();\n    }\n    else {\n      engine.gestureSelectionEnd();\n    }\n  },\n};\n/**\n * Check to see if the Haptic Plugin is available\n * @return Returns `true` or false if the plugin is available\n */\nconst hapticAvailable = () => {\n  return HapticEngine.available();\n};\n/**\n * Trigger a selection changed haptic event. Good for one-time events\n * (not for gestures)\n */\nconst hapticSelection = () => {\n  hapticAvailable() && HapticEngine.selection();\n};\n/**\n * Tell the haptic engine that a gesture for a selection change is starting.\n */\nconst hapticSelectionStart = () => {\n  hapticAvailable() && HapticEngine.selectionStart();\n};\n/**\n * Tell the haptic engine that a selection changed during a gesture.\n */\nconst hapticSelectionChanged = () => {\n  hapticAvailable() && HapticEngine.selectionChanged();\n};\n/**\n * Tell the haptic engine we are done with a gesture. This needs to be\n * called lest resources are not properly recycled.\n */\nconst hapticSelectionEnd = () => {\n  hapticAvailable() && HapticEngine.selectionEnd();\n};\n/**\n * Use this to indicate success/failure/warning to the user.\n * options should be of the type `{ style: 'light' }` (or `medium`/`heavy`)\n */\nconst hapticImpact = (options) => {\n  hapticAvailable() && HapticEngine.impact(options);\n};\n\nexport { hapticSelectionStart as a, hapticSelectionChanged as b, hapticSelectionEnd as c, hapticSelection as d, hapticImpact as h };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}