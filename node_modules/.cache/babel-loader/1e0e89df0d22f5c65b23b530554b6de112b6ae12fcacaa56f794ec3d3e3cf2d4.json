{"ast":null,"code":"import _defineProperty from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, writeTask, readTask, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, p as printIonContentErrorMsg, g as getScrollElement } from './index9.js';\nvar infiniteScrollCss = \"ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}\";\nvar InfiniteScroll = /*@__PURE__*/proxyCustomElement( /*#__PURE__*/function (_HTMLElement) {\n  _inherits(_class, _HTMLElement);\n  var _super = _createSuper(_class);\n  function _class() {\n    var _this;\n    _classCallCheck(this, _class);\n    _this = _super.call(this);\n    _this.__registerHost();\n    _this.ionInfinite = createEvent(_assertThisInitialized(_this), \"ionInfinite\", 7);\n    _this.thrPx = 0;\n    _this.thrPc = 0;\n    _this.didFire = false;\n    _this.isBusy = false;\n    _this.isLoading = false;\n    /**\n     * The threshold distance from the bottom\n     * of the content to call the `infinite` output event when scrolled.\n     * The threshold value can be either a percent, or\n     * in pixels. For example, use the value of `10%` for the `infinite`\n     * output event to get called when the user has scrolled 10%\n     * from the bottom of the page. Use the value `100px` when the\n     * scroll is within 100 pixels from the bottom of the page.\n     */\n    _this.threshold = '15%';\n    /**\n     * If `true`, the infinite scroll will be hidden and scroll event listeners\n     * will be removed.\n     *\n     * Set this to true to disable the infinite scroll from actively\n     * trying to receive new data while scrolling. This is useful\n     * when it is known that there is no more data that can be added, and\n     * the infinite scroll is no longer needed.\n     */\n    _this.disabled = false;\n    /**\n     * The position of the infinite scroll element.\n     * The value can be either `top` or `bottom`.\n     */\n    _this.position = 'bottom';\n    _this.onScroll = function () {\n      var scrollEl = _this.scrollEl;\n      if (!scrollEl || !_this.canStart()) {\n        return 1;\n      }\n      var infiniteHeight = _this.el.offsetHeight;\n      if (infiniteHeight === 0) {\n        // if there is no height of this element then do nothing\n        return 2;\n      }\n      var scrollTop = scrollEl.scrollTop;\n      var scrollHeight = scrollEl.scrollHeight;\n      var height = scrollEl.offsetHeight;\n      var threshold = _this.thrPc !== 0 ? height * _this.thrPc : _this.thrPx;\n      var distanceFromInfinite = _this.position === 'bottom' ? scrollHeight - infiniteHeight - scrollTop - threshold - height : scrollTop - infiniteHeight - threshold;\n      if (distanceFromInfinite < 0) {\n        if (!_this.didFire) {\n          _this.isLoading = true;\n          _this.didFire = true;\n          _this.ionInfinite.emit();\n          return 3;\n        }\n      } else {\n        _this.didFire = false;\n      }\n      return 4;\n    };\n    return _this;\n  }\n  _createClass(_class, [{\n    key: \"thresholdChanged\",\n    value: function thresholdChanged() {\n      var val = this.threshold;\n      if (val.lastIndexOf('%') > -1) {\n        this.thrPx = 0;\n        this.thrPc = parseFloat(val) / 100;\n      } else {\n        this.thrPx = parseFloat(val);\n        this.thrPc = 0;\n      }\n    }\n  }, {\n    key: \"disabledChanged\",\n    value: function disabledChanged() {\n      var disabled = this.disabled;\n      if (disabled) {\n        this.isLoading = false;\n        this.isBusy = false;\n      }\n      this.enableScrollEvents(!disabled);\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var contentEl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              contentEl = findClosestIonContent(this.el);\n              if (contentEl) {\n                _context.next = 4;\n                break;\n              }\n              printIonContentErrorMsg(this.el);\n              return _context.abrupt(\"return\");\n            case 4:\n              _context.next = 6;\n              return getScrollElement(contentEl);\n            case 6:\n              this.scrollEl = _context.sent;\n              this.thresholdChanged();\n              this.disabledChanged();\n              if (this.position === 'top') {\n                writeTask(function () {\n                  if (_this2.scrollEl) {\n                    _this2.scrollEl.scrollTop = _this2.scrollEl.scrollHeight - _this2.scrollEl.clientHeight;\n                  }\n                });\n              }\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n      return connectedCallback;\n    }()\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      this.enableScrollEvents(false);\n      this.scrollEl = undefined;\n    }\n    /**\n     * Call `complete()` within the `ionInfinite` output event handler when\n     * your async operation has completed. For example, the `loading`\n     * state is while the app is performing an asynchronous operation,\n     * such as receiving more data from an AJAX request to add more items\n     * to a data list. Once the data has been received and UI updated, you\n     * then call this method to signify that the loading has completed.\n     * This method will change the infinite scroll's state from `loading`\n     * to `enabled`.\n     */\n  }, {\n    key: \"complete\",\n    value: function () {\n      var _complete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this3 = this;\n        var scrollEl, prev;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              scrollEl = this.scrollEl;\n              if (!(!this.isLoading || !scrollEl)) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 3:\n              this.isLoading = false;\n              if (this.position === 'top') {\n                /**\n                 * New content is being added at the top, but the scrollTop position stays the same,\n                 * which causes a scroll jump visually. This algorithm makes sure to prevent this.\n                 * (Frame 1)\n                 *    - complete() is called, but the UI hasn't had time to update yet.\n                 *    - Save the current content dimensions.\n                 *    - Wait for the next frame using _dom.read, so the UI will be updated.\n                 * (Frame 2)\n                 *    - Read the new content dimensions.\n                 *    - Calculate the height difference and the new scroll position.\n                 *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.\n                 * (Still frame 2, if I'm correct)\n                 *    - Change the scroll position (= visually maintain the scroll position).\n                 *    - Change the state to re-enable the InfiniteScroll.\n                 *    - This should be after changing the scroll position, or it could\n                 *    cause the InfiniteScroll to be triggered again immediately.\n                 * (Frame 3)\n                 *    Done.\n                 */\n                this.isBusy = true;\n                // ******** DOM READ ****************\n                // Save the current content dimensions before the UI updates\n                prev = scrollEl.scrollHeight - scrollEl.scrollTop; // ******** DOM READ ****************\n                requestAnimationFrame(function () {\n                  readTask(function () {\n                    // UI has updated, save the new content dimensions\n                    var scrollHeight = scrollEl.scrollHeight;\n                    // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around\n                    var newScrollTop = scrollHeight - prev;\n                    // ******** DOM WRITE ****************\n                    requestAnimationFrame(function () {\n                      writeTask(function () {\n                        scrollEl.scrollTop = newScrollTop;\n                        _this3.isBusy = false;\n                      });\n                    });\n                  });\n                });\n              }\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function complete() {\n        return _complete.apply(this, arguments);\n      }\n      return complete;\n    }()\n  }, {\n    key: \"canStart\",\n    value: function canStart() {\n      return !this.disabled && !this.isBusy && !!this.scrollEl && !this.isLoading;\n    }\n  }, {\n    key: \"enableScrollEvents\",\n    value: function enableScrollEvents(shouldListen) {\n      if (this.scrollEl) {\n        if (shouldListen) {\n          this.scrollEl.addEventListener('scroll', this.onScroll);\n        } else {\n          this.scrollEl.removeEventListener('scroll', this.onScroll);\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _class2;\n      var mode = getIonMode(this);\n      var disabled = this.disabled;\n      return h(Host, {\n        class: (_class2 = {}, _defineProperty(_class2, mode, true), _defineProperty(_class2, 'infinite-scroll-loading', this.isLoading), _defineProperty(_class2, 'infinite-scroll-enabled', !disabled), _class2)\n      });\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"threshold\": [\"thresholdChanged\"],\n        \"disabled\": [\"disabledChanged\"]\n      };\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return infiniteScrollCss;\n    }\n  }]);\n  return _class;\n}(HTMLElement), [0, \"ion-infinite-scroll\", {\n  \"threshold\": [1],\n  \"disabled\": [4],\n  \"position\": [1],\n  \"isLoading\": [32],\n  \"complete\": [64]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  var components = [\"ion-infinite-scroll\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-infinite-scroll\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, InfiniteScroll);\n        }\n        break;\n    }\n  });\n}\nvar IonInfiniteScroll = InfiniteScroll;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonInfiniteScroll, defineCustomElement };","map":{"version":3,"names":["proxyCustomElement","HTMLElement","createEvent","writeTask","readTask","h","Host","b","getIonMode","a","findClosestIonContent","p","printIonContentErrorMsg","g","getScrollElement","infiniteScrollCss","InfiniteScroll","__registerHost","ionInfinite","thrPx","thrPc","didFire","isBusy","isLoading","threshold","disabled","position","onScroll","scrollEl","canStart","infiniteHeight","el","offsetHeight","scrollTop","scrollHeight","height","distanceFromInfinite","emit","val","lastIndexOf","parseFloat","enableScrollEvents","contentEl","thresholdChanged","disabledChanged","clientHeight","undefined","prev","requestAnimationFrame","newScrollTop","shouldListen","addEventListener","removeEventListener","mode","class","defineCustomElement$1","customElements","components","forEach","tagName","get","define","IonInfiniteScroll","defineCustomElement"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@ionic/core/components/ion-infinite-scroll.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, writeTask, readTask, h, Host } from '@stencil/core/internal/client';\nimport { b as getIonMode } from './ionic-global.js';\nimport { a as findClosestIonContent, p as printIonContentErrorMsg, g as getScrollElement } from './index9.js';\n\nconst infiniteScrollCss = \"ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}\";\n\nconst InfiniteScroll = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionInfinite = createEvent(this, \"ionInfinite\", 7);\n    this.thrPx = 0;\n    this.thrPc = 0;\n    this.didFire = false;\n    this.isBusy = false;\n    this.isLoading = false;\n    /**\n     * The threshold distance from the bottom\n     * of the content to call the `infinite` output event when scrolled.\n     * The threshold value can be either a percent, or\n     * in pixels. For example, use the value of `10%` for the `infinite`\n     * output event to get called when the user has scrolled 10%\n     * from the bottom of the page. Use the value `100px` when the\n     * scroll is within 100 pixels from the bottom of the page.\n     */\n    this.threshold = '15%';\n    /**\n     * If `true`, the infinite scroll will be hidden and scroll event listeners\n     * will be removed.\n     *\n     * Set this to true to disable the infinite scroll from actively\n     * trying to receive new data while scrolling. This is useful\n     * when it is known that there is no more data that can be added, and\n     * the infinite scroll is no longer needed.\n     */\n    this.disabled = false;\n    /**\n     * The position of the infinite scroll element.\n     * The value can be either `top` or `bottom`.\n     */\n    this.position = 'bottom';\n    this.onScroll = () => {\n      const scrollEl = this.scrollEl;\n      if (!scrollEl || !this.canStart()) {\n        return 1;\n      }\n      const infiniteHeight = this.el.offsetHeight;\n      if (infiniteHeight === 0) {\n        // if there is no height of this element then do nothing\n        return 2;\n      }\n      const scrollTop = scrollEl.scrollTop;\n      const scrollHeight = scrollEl.scrollHeight;\n      const height = scrollEl.offsetHeight;\n      const threshold = this.thrPc !== 0 ? height * this.thrPc : this.thrPx;\n      const distanceFromInfinite = this.position === 'bottom'\n        ? scrollHeight - infiniteHeight - scrollTop - threshold - height\n        : scrollTop - infiniteHeight - threshold;\n      if (distanceFromInfinite < 0) {\n        if (!this.didFire) {\n          this.isLoading = true;\n          this.didFire = true;\n          this.ionInfinite.emit();\n          return 3;\n        }\n      }\n      else {\n        this.didFire = false;\n      }\n      return 4;\n    };\n  }\n  thresholdChanged() {\n    const val = this.threshold;\n    if (val.lastIndexOf('%') > -1) {\n      this.thrPx = 0;\n      this.thrPc = parseFloat(val) / 100;\n    }\n    else {\n      this.thrPx = parseFloat(val);\n      this.thrPc = 0;\n    }\n  }\n  disabledChanged() {\n    const disabled = this.disabled;\n    if (disabled) {\n      this.isLoading = false;\n      this.isBusy = false;\n    }\n    this.enableScrollEvents(!disabled);\n  }\n  async connectedCallback() {\n    const contentEl = findClosestIonContent(this.el);\n    if (!contentEl) {\n      printIonContentErrorMsg(this.el);\n      return;\n    }\n    this.scrollEl = await getScrollElement(contentEl);\n    this.thresholdChanged();\n    this.disabledChanged();\n    if (this.position === 'top') {\n      writeTask(() => {\n        if (this.scrollEl) {\n          this.scrollEl.scrollTop = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;\n        }\n      });\n    }\n  }\n  disconnectedCallback() {\n    this.enableScrollEvents(false);\n    this.scrollEl = undefined;\n  }\n  /**\n   * Call `complete()` within the `ionInfinite` output event handler when\n   * your async operation has completed. For example, the `loading`\n   * state is while the app is performing an asynchronous operation,\n   * such as receiving more data from an AJAX request to add more items\n   * to a data list. Once the data has been received and UI updated, you\n   * then call this method to signify that the loading has completed.\n   * This method will change the infinite scroll's state from `loading`\n   * to `enabled`.\n   */\n  async complete() {\n    const scrollEl = this.scrollEl;\n    if (!this.isLoading || !scrollEl) {\n      return;\n    }\n    this.isLoading = false;\n    if (this.position === 'top') {\n      /**\n       * New content is being added at the top, but the scrollTop position stays the same,\n       * which causes a scroll jump visually. This algorithm makes sure to prevent this.\n       * (Frame 1)\n       *    - complete() is called, but the UI hasn't had time to update yet.\n       *    - Save the current content dimensions.\n       *    - Wait for the next frame using _dom.read, so the UI will be updated.\n       * (Frame 2)\n       *    - Read the new content dimensions.\n       *    - Calculate the height difference and the new scroll position.\n       *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.\n       * (Still frame 2, if I'm correct)\n       *    - Change the scroll position (= visually maintain the scroll position).\n       *    - Change the state to re-enable the InfiniteScroll.\n       *    - This should be after changing the scroll position, or it could\n       *    cause the InfiniteScroll to be triggered again immediately.\n       * (Frame 3)\n       *    Done.\n       */\n      this.isBusy = true;\n      // ******** DOM READ ****************\n      // Save the current content dimensions before the UI updates\n      const prev = scrollEl.scrollHeight - scrollEl.scrollTop;\n      // ******** DOM READ ****************\n      requestAnimationFrame(() => {\n        readTask(() => {\n          // UI has updated, save the new content dimensions\n          const scrollHeight = scrollEl.scrollHeight;\n          // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around\n          const newScrollTop = scrollHeight - prev;\n          // ******** DOM WRITE ****************\n          requestAnimationFrame(() => {\n            writeTask(() => {\n              scrollEl.scrollTop = newScrollTop;\n              this.isBusy = false;\n            });\n          });\n        });\n      });\n    }\n  }\n  canStart() {\n    return !this.disabled && !this.isBusy && !!this.scrollEl && !this.isLoading;\n  }\n  enableScrollEvents(shouldListen) {\n    if (this.scrollEl) {\n      if (shouldListen) {\n        this.scrollEl.addEventListener('scroll', this.onScroll);\n      }\n      else {\n        this.scrollEl.removeEventListener('scroll', this.onScroll);\n      }\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    const disabled = this.disabled;\n    return (h(Host, { class: {\n        [mode]: true,\n        'infinite-scroll-loading': this.isLoading,\n        'infinite-scroll-enabled': !disabled,\n      } }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"threshold\": [\"thresholdChanged\"],\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n  static get style() { return infiniteScrollCss; }\n}, [0, \"ion-infinite-scroll\", {\n    \"threshold\": [1],\n    \"disabled\": [4],\n    \"position\": [1],\n    \"isLoading\": [32],\n    \"complete\": [64]\n  }]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-infinite-scroll\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-infinite-scroll\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, InfiniteScroll);\n      }\n      break;\n  } });\n}\n\nconst IonInfiniteScroll = InfiniteScroll;\nconst defineCustomElement = defineCustomElement$1;\n\nexport { IonInfiniteScroll, defineCustomElement };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}