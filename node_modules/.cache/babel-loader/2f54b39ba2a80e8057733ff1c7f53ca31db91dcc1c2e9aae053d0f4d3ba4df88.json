{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _construct from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\nvar Router = /*#__PURE__*/function () {\n  /**\n   * Initializes a new Router.\n   */\n  function Router() {\n    _classCallCheck(this, Router);\n    this._routes = new Map();\n  }\n  /**\n   * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  _createClass(Router, [{\n    key: \"routes\",\n    get: function get() {\n      return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n  }, {\n    key: \"addFetchListener\",\n    value: function addFetchListener() {\n      var _this = this;\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('fetch', function (event) {\n        var request = event.request;\n        var responsePromise = _this.handleRequest({\n          request: request,\n          event: event\n        });\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n  }, {\n    key: \"addCacheListener\",\n    value: function addCacheListener() {\n      var _this2 = this;\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('message', function (event) {\n        if (event.data && event.data.type === 'CACHE_URLS') {\n          var payload = event.data.payload;\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n          }\n          var requestPromises = Promise.all(payload.urlsToCache.map(function (entry) {\n            if (typeof entry === 'string') {\n              entry = [entry];\n            }\n            var request = _construct(Request, _toConsumableArray(entry));\n            return _this2.handleRequest({\n              request: request\n            });\n            // TODO(philipwalton): TypeScript errors without this typecast for\n            // some reason (probably a bug). The real type here should work but\n            // doesn't: `Array<Promise<Response> | undefined>`.\n          })); // TypeScript\n          event.waitUntil(requestPromises);\n          // If a MessageChannel was used, reply to the message on success.\n          if (event.ports && event.ports[0]) {\n            requestPromises.then(function () {\n              return event.ports[0].postMessage(true);\n            });\n          }\n        }\n      });\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(_ref) {\n      var _this3 = this;\n      var request = _ref.request,\n        event = _ref.event;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'options.request'\n        });\n      }\n      var url = new URL(request.url, location.href);\n      if (!url.protocol.startsWith('http')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n        }\n        return;\n      }\n      var _this$findMatchingRou = this.findMatchingRoute({\n          url: url,\n          request: request,\n          event: event\n        }),\n        params = _this$findMatchingRou.params,\n        route = _this$findMatchingRou.route;\n      var handler = route && route.handler;\n      var debugMessages = [];\n      if (process.env.NODE_ENV !== 'production') {\n        if (handler) {\n          debugMessages.push([\"Found a route to handle this request:\", route]);\n          if (params) {\n            debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n          }\n        }\n      }\n      // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n      if (!handler && this._defaultHandler) {\n        if (process.env.NODE_ENV !== 'production') {\n          debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler.\");\n        }\n        handler = this._defaultHandler;\n      }\n      if (!handler) {\n        if (process.env.NODE_ENV !== 'production') {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n        }\n        return;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n        debugMessages.forEach(function (msg) {\n          if (Array.isArray(msg)) {\n            logger.log.apply(logger, _toConsumableArray(msg));\n          } else {\n            logger.log(msg);\n          }\n        });\n        logger.groupEnd();\n      }\n      // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n      var responsePromise;\n      try {\n        responsePromise = handler.handle({\n          url: url,\n          request: request,\n          event: event,\n          params: params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      }\n      if (responsePromise instanceof Promise && this._catchHandler) {\n        responsePromise = responsePromise.catch(function (err) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to Catch Handler.\"));\n            logger.error(\"Error thrown by:\", route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          return _this3._catchHandler.handle({\n            url: url,\n            request: request,\n            event: event\n          });\n        });\n      }\n      return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n  }, {\n    key: \"findMatchingRoute\",\n    value: function findMatchingRoute(_ref2) {\n      var url = _ref2.url,\n        request = _ref2.request,\n        event = _ref2.event;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(url, URL, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.url'\n        });\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.request'\n        });\n      }\n      var routes = this._routes.get(request.method) || [];\n      var _iterator = _createForOfIteratorHelper(routes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var route = _step.value;\n          var params = void 0;\n          var matchResult = route.match({\n            url: url,\n            request: request,\n            event: event\n          });\n          if (matchResult) {\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            params = matchResult;\n            if (Array.isArray(matchResult) && matchResult.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            }\n            // Return early if have a match.\n            return {\n              route: route,\n              params: params\n            };\n          }\n        }\n        // If no match was found above, return and empty object.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n  }, {\n    key: \"setDefaultHandler\",\n    value: function setDefaultHandler(handler) {\n      this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n  }, {\n    key: \"setCatchHandler\",\n    value: function setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to register.\n     */\n  }, {\n    key: \"registerRoute\",\n    value: function registerRoute(route) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      }\n      // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n      this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to unregister.\n     */\n  }, {\n    key: \"unregisterRoute\",\n    value: function unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n      var routeIndex = this._routes.get(route.method).indexOf(route);\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n  }]);\n  return Router;\n}();\nexport { Router };","map":{"version":3,"names":["assert","logger","WorkboxError","getFriendlyURL","normalizeHandler","Router","_routes","Map","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","findMatchingRoute","params","route","handler","debugMessages","push","_defaultHandler","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","_catchHandler","catch","error","routes","get","method","matchResult","match","length","undefined","constructor","Object","keys","isType","hasMethod","has","set","routeIndex","indexOf","splice"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/workbox-routing/Router.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n    }\n    /**\n     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const { params, route } = this.findMatchingRoute({ url, request, event });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([\n                    `Found a route to handle this request:`, route,\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`, params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        if (!handler && this._defaultHandler) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler.`);\n            }\n            handler = this._defaultHandler;\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        if (responsePromise instanceof Promise && this._catchHandler) {\n            responsePromise = responsePromise.catch((err) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(`Error thrown when responding to: ` +\n                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n                    logger.error(`Error thrown by:`, route);\n                    logger.error(err);\n                    logger.groupEnd();\n                }\n                return this._catchHandler.handle({ url, request, event });\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(url, URL, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.url',\n            });\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.request',\n            });\n        }\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            const matchResult = route.match({ url, request, event });\n            if (matchResult) {\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                params = matchResult;\n                if (Array.isArray(matchResult) && matchResult.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if ((matchResult.constructor === Object &&\n                    Object.keys(matchResult).length === 0)) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setDefaultHandler(handler) {\n        this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}