{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport var DBWrapper = /*#__PURE__*/function () {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  function DBWrapper(name, version) {\n    var _this = this;\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      onupgradeneeded = _ref.onupgradeneeded,\n      onversionchange = _ref.onversionchange;\n    _classCallCheck(this, DBWrapper);\n    this._db = null;\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange || function () {\n      return _this.close();\n    };\n  }\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   * @return {IDBDatabase|undefined}\n   *\n   * @private\n   */\n  _createClass(DBWrapper, [{\n    key: \"db\",\n    get: function get() {\n      return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._db) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              _context.next = 4;\n              return new Promise(function (resolve, reject) {\n                // This flag is flipped to true if the timeout callback runs prior\n                // to the request failing or succeeding. Note: we use a timeout instead\n                // of an onblocked handler since there are cases where onblocked will\n                // never never run. A timeout better handles all possible scenarios:\n                // https://github.com/w3c/IndexedDB/issues/223\n                var openRequestTimedOut = false;\n                setTimeout(function () {\n                  openRequestTimedOut = true;\n                  reject(new Error('The open request was blocked and timed out'));\n                }, _this2.OPEN_TIMEOUT);\n                var openRequest = indexedDB.open(_this2._name, _this2._version);\n                openRequest.onerror = function () {\n                  return reject(openRequest.error);\n                };\n                openRequest.onupgradeneeded = function (evt) {\n                  if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                  } else if (typeof _this2._onupgradeneeded === 'function') {\n                    _this2._onupgradeneeded(evt);\n                  }\n                };\n                openRequest.onsuccess = function () {\n                  var db = openRequest.result;\n                  if (openRequestTimedOut) {\n                    db.close();\n                  } else {\n                    db.onversionchange = _this2._onversionchange.bind(_this2);\n                    resolve(db);\n                  }\n                };\n              });\n            case 4:\n              this._db = _context.sent;\n              return _context.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function open() {\n        return _open.apply(this, arguments);\n      }\n      return open;\n    }()\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n  }, {\n    key: \"getKey\",\n    value: function () {\n      var _getKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(storeName, query) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getAllKeys(storeName, query, 1);\n            case 2:\n              return _context2.abrupt(\"return\", _context2.sent[0]);\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getKey(_x, _x2) {\n        return _getKey.apply(this, arguments);\n      }\n      return getKey;\n    }()\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n  }, {\n    key: \"getAll\",\n    value: function () {\n      var _getAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(storeName, query, count) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getAllMatching(storeName, {\n                query: query,\n                count: count\n              });\n            case 2:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getAll(_x3, _x4, _x5) {\n        return _getAll.apply(this, arguments);\n      }\n      return getAll;\n    }()\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n  }, {\n    key: \"getAllKeys\",\n    value: function () {\n      var _getAllKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(storeName, query, count) {\n        var entries;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.getAllMatching(storeName, {\n                query: query,\n                count: count,\n                includeKeys: true\n              });\n            case 2:\n              entries = _context4.sent;\n              return _context4.abrupt(\"return\", entries.map(function (entry) {\n                return entry.key;\n              }));\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getAllKeys(_x6, _x7, _x8) {\n        return _getAllKeys.apply(this, arguments);\n      }\n      return getAllKeys;\n    }()\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n  }, {\n    key: \"getAllMatching\",\n    value: function () {\n      var _getAllMatching = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(storeName) {\n        var _ref2,\n          index,\n          _ref2$query,\n          query,\n          _ref2$direction,\n          direction,\n          count,\n          _ref2$includeKeys,\n          includeKeys,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _ref2 = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {}, index = _ref2.index, _ref2$query = _ref2.query, query = _ref2$query === void 0 ? null : _ref2$query, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? 'next' : _ref2$direction, count = _ref2.count, _ref2$includeKeys = _ref2.includeKeys, includeKeys = _ref2$includeKeys === void 0 ? false : _ref2$includeKeys;\n              _context5.next = 3;\n              return this.transaction([storeName], 'readonly', function (txn, done) {\n                var store = txn.objectStore(storeName);\n                var target = index ? store.index(index) : store;\n                var results = [];\n                var request = target.openCursor(query, direction);\n                request.onsuccess = function () {\n                  var cursor = request.result;\n                  if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                      done(results);\n                    } else {\n                      cursor.continue();\n                    }\n                  } else {\n                    done(results);\n                  }\n                };\n              });\n            case 3:\n              return _context5.abrupt(\"return\", _context5.sent);\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getAllMatching(_x9) {\n        return _getAllMatching.apply(this, arguments);\n      }\n      return getAllMatching;\n    }()\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n  }, {\n    key: \"transaction\",\n    value: function () {\n      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(storeNames, type, callback) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.open();\n            case 2:\n              _context6.next = 4;\n              return new Promise(function (resolve, reject) {\n                var txn = _this3._db.transaction(storeNames, type);\n                txn.onabort = function () {\n                  return reject(txn.error);\n                };\n                txn.oncomplete = function () {\n                  return resolve();\n                };\n                callback(txn, function (value) {\n                  return resolve(value);\n                });\n              });\n            case 4:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function transaction(_x10, _x11, _x12) {\n        return _transaction.apply(this, arguments);\n      }\n      return transaction;\n    }()\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n  }, {\n    key: \"_call\",\n    value: function () {\n      var _call2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(method, storeName, type) {\n        var _len,\n          args,\n          _key,\n          callback,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              for (_len = _args7.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n                args[_key - 3] = _args7[_key];\n              }\n              callback = function callback(txn, done) {\n                var objStore = txn.objectStore(storeName);\n                // TODO(philipwalton): Fix this underlying TS2684 error.\n                // @ts-ignore\n                var request = objStore[method].apply(objStore, args);\n                request.onsuccess = function () {\n                  return done(request.result);\n                };\n              };\n              _context7.next = 4;\n              return this.transaction([storeName], type, callback);\n            case 4:\n              return _context7.abrupt(\"return\", _context7.sent);\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _call(_x13, _x14, _x15) {\n        return _call2.apply(this, arguments);\n      }\n      return _call;\n    }()\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._db) {\n        this._db.close();\n        this._db = null;\n      }\n    }\n  }]);\n  return DBWrapper;\n}();\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nvar methodsToWrap = {\n  readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  readwrite: ['add', 'put', 'clear', 'delete']\n};\nvar _loop = function _loop() {\n  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n    mode = _Object$entries$_i[0],\n    methods = _Object$entries$_i[1];\n  var _iterator = _createForOfIteratorHelper(methods),\n    _step;\n  try {\n    var _loop2 = function _loop2() {\n      var method = _step.value;\n      if (method in IDBObjectStore.prototype) {\n        // Don't use arrow functions here since we're outside of the class.\n        DBWrapper.prototype[method] = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(storeName) {\n            var _len2,\n              args,\n              _key2,\n              _args8 = arguments;\n            return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n              while (1) switch (_context8.prev = _context8.next) {\n                case 0:\n                  for (_len2 = _args8.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    args[_key2 - 1] = _args8[_key2];\n                  }\n                  _context8.next = 3;\n                  return this._call.apply(this, [method, storeName, mode].concat(args));\n                case 3:\n                  return _context8.abrupt(\"return\", _context8.sent);\n                case 4:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }, _callee8, this);\n          }));\n          return function (_x16) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nfor (var _i = 0, _Object$entries = Object.entries(methodsToWrap); _i < _Object$entries.length; _i++) {\n  _loop();\n}","map":{"version":3,"names":["DBWrapper","name","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","result","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","entries","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","length","continue","storeNames","type","callback","onabort","oncomplete","method","args","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","IDBObjectStore","_call","Object"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/workbox-core/_private/DBWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            // TODO(philipwalton): Fix this underlying TS2684 error.\n            // @ts-ignore\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}