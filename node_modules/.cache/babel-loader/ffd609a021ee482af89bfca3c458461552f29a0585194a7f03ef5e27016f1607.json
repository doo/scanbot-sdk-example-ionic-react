{"ast":null,"code":"import _regeneratorRuntime from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers.js';\nimport { b as printRequiredElementError } from './index8.js';\nvar ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nvar ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nvar ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nvar ION_CONTENT_SELECTOR = \"\".concat(ION_CONTENT_ELEMENT_SELECTOR, \", \").concat(ION_CONTENT_CLASS_SELECTOR);\nvar isIonContent = function isIonContent(el) {\n  return el.tagName === ION_CONTENT_TAG_NAME;\n};\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nvar getScrollElement = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(el) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!isIonContent(el)) {\n            _context.next = 4;\n            break;\n          }\n          _context.next = 3;\n          return new Promise(function (resolve) {\n            return componentOnReady(el, resolve);\n          });\n        case 3:\n          return _context.abrupt(\"return\", el.getScrollElement());\n        case 4:\n          return _context.abrupt(\"return\", el);\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getScrollElement(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nvar findIonContent = function findIonContent(el) {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  var customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nvar findClosestIonContent = function findClosestIonContent(el) {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\nvar scrollToTop = function scrollToTop(el, durationMs) {\n  if (isIonContent(el)) {\n    var content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nvar scrollByPoint = function scrollByPoint(el, x, y, durationMs) {\n  if (isIonContent(el)) {\n    var content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nvar printIonContentErrorMsg = function printIonContentErrorMsg(el) {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nvar disableContentScrollY = function disableContentScrollY(contentEl) {\n  if (isIonContent(contentEl)) {\n    var ionContent = contentEl;\n    var initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  } else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nvar resetContentScrollY = function resetContentScrollY(contentEl, initialScrollY) {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  } else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\nexport { ION_CONTENT_ELEMENT_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_CLASS_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };","map":{"version":3,"names":["c","componentOnReady","b","printRequiredElementError","ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","tagName","getScrollElement","Promise","resolve","findIonContent","customContentHost","querySelector","findClosestIonContent","closest","scrollToTop","durationMs","content","scrollTo","top","left","behavior","scrollByPoint","x","y","scrollBy","printIonContentErrorMsg","disableContentScrollY","contentEl","ionContent","initialScrollY","scrollY","style","setProperty","resetContentScrollY","removeProperty","I","a","d","f","g","i","p","r","s"],"sources":["/Users/chanduranwala/Scanbot/ionic/scanbot-sdk-example-ionic-react/node_modules/@ionic/core/components/index9.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers.js';\nimport { b as printRequiredElementError } from './index8.js';\n\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nconst isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nconst getScrollElement = async (el) => {\n  if (isIonContent(el)) {\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nconst findIonContent = (el) => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nconst findClosestIonContent = (el) => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\nconst scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nconst scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nconst printIonContentErrorMsg = (el) => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nconst disableContentScrollY = (contentEl) => {\n  if (isIonContent(contentEl)) {\n    const ionContent = contentEl;\n    const initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  }\n  else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nconst resetContentScrollY = (contentEl, initialScrollY) => {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  }\n  else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\n\nexport { ION_CONTENT_ELEMENT_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_CLASS_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}